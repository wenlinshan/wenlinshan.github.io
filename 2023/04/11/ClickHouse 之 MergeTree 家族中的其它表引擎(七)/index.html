<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>ClickHouse 之 MergeTree 家族中的其它表引擎(七) | 热心市民温温</title><meta name="author" content="wenwen"><meta name="copyright" content="wenwen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ClickHouse 之 MergeTree 家族中的其它表引擎(七)​																	本文来源： ( https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;tag&#x2F;ClickHouse：一款速度快到让人发指的列式存储数据库&#x2F; )   目前在 ClickHouse 中，按照特点可以将表引擎分为 6 个系列，分别是合并树、外部存储、内存、文件、接口和其它，每一个系">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse 之 MergeTree 家族中的其它表引擎(七)">
<meta property="og:url" content="https://hesay.cn/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/index.html">
<meta property="og:site_name" content="热心市民温温">
<meta property="og:description" content="ClickHouse 之 MergeTree 家族中的其它表引擎(七)​																	本文来源： ( https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;tag&#x2F;ClickHouse：一款速度快到让人发指的列式存储数据库&#x2F; )   目前在 ClickHouse 中，按照特点可以将表引擎分为 6 个系列，分别是合并树、外部存储、内存、文件、接口和其它，每一个系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hesay.cn/img/favicon.png">
<meta property="article:published_time" content="2023-04-11T09:04:31.000Z">
<meta property="article:modified_time" content="2023-04-13T09:06:57.974Z">
<meta property="article:author" content="wenwen">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hesay.cn/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hesay.cn/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ClickHouse 之 MergeTree 家族中的其它表引擎(七)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-13 17:06:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="热心市民温温"><span class="site-name">热心市民温温</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-13T09:06:57.974Z" title="更新于 2023-04-13 17:06:57">2023-04-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ClickHouse/">ClickHouse</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="ClickHouse-之-MergeTree-家族中的其它表引擎-七"><a href="#ClickHouse-之-MergeTree-家族中的其它表引擎-七" class="headerlink" title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)"></a>ClickHouse 之 MergeTree 家族中的其它表引擎(七)</h1><p>​																	本文来源： ( <a target="_blank" rel="noopener" href="https://www.cnblogs.com/traditional/tag/ClickHouse%EF%BC%9A%E4%B8%80%E6%AC%BE%E9%80%9F%E5%BA%A6%E5%BF%AB%E5%88%B0%E8%AE%A9%E4%BA%BA%E5%8F%91%E6%8C%87%E7%9A%84%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93/">https://www.cnblogs.com/traditional/tag/ClickHouse：一款速度快到让人发指的列式存储数据库/</a> ) </p>
<hr>
<p><strong>目前在 ClickHouse 中，按照特点可以将表引擎分为 6 个系列，分别是合并树、外部存储、内存、文件、接口和其它，每一个系列的表引擎都有独自的特点和使用场景。而其中最核心的当属 MergeTree 系列，因为它们拥有最为强大的性能和最为广泛的使用场景。</strong></p>
<p><strong>经过之前的介绍，我们知道 MergeTree 有两种含义：</strong></p>
<ul>
<li><code>1. 表示合并树表引擎家族</code></li>
<li><code>2. 表示合并树表引擎家族中最基础的 MergeTree 表引擎</code></li>
</ul>
<p><strong>而在整个家族中，除了基础表引擎 MergeTree 之外，常用的表引擎还有 ReplacingMergeTree、SummingMergeTree、AggregatingMergeTree、CollapsingMergeTree、VersionedCollapsingMergeTree。从名字也能看出来，每一种合并树的变种，在继承了 MergeTree 的基础能力后，又增加了独有的特性，而这些独有的特性都是在触发合并的过程中被激活的。</strong></p>
<h3 id="MergeTree"><a href="#MergeTree" class="headerlink" title="MergeTree"></a>MergeTree</h3><p><strong>MergeTree 作为家族系列最基础的表引擎，提供了数据分区、一级索引和二级索引等功能，至于它们的运行机理我们之前已经介绍过了。这里我们来介绍一下 MergeTree 的另外两个功能：数据 TTL 和 存储策略。</strong></p>
<h4 id="数据-TTL"><a href="#数据-TTL" class="headerlink" title="数据 TTL"></a>数据 TTL</h4><p><strong>TTL 即 Time To Live，表示数据的存活时间，而在 MergeTree 中可以为某个列字段或整张表设置 TTL。当时间到达时，如果是列字段级别的 TTL，则会删除这一列的数据；如果是整张表级别的 TTL，则会删除整张表的数据；如果同时设置，则会以先到期的为主。</strong></p>
<p><strong>无论是列级别还是表级别的 TTL，都需要依托某个 DateTime 或 Date 类型的字段，通过对这个时间字段的 INTERVAL 操作来表述 TTL 的过期时间，下面我们看一下设置的方式。</strong></p>
<p><strong>1）列级别设置 TTL</strong></p>
<p><strong>如果想要设置列级别的 TTL，则需要在定义表字段的时候为它们声明 TTL 表达式，主键字段不能被声明 TTL，举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ttl_table_v1 (</span><br><span class="line">    id String,</span><br><span class="line">    create_time DateTime,</span><br><span class="line">    code String TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span>,</span><br><span class="line">    type UInt8 TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span> </span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>

<p><strong>其中 create_time 是日期类型，列字段 code 和 type 均被设置了 TTL，它们的存活时间在 create_time 取值的基础之上向后延续 10 秒。假设某一条数据的 create_time 的值为 dt，那么当系统时间超过了 dt + 10 秒，该条数据的 code、type 就会过期。</strong></p>
<blockquote>
<p><strong>除了 SECOND 之外，还有 MINUTE、HOUR、DAY、WEEK、MONTH、QUARTER 和 YEAR。</strong></p>
</blockquote>
<p><strong>现在写入两条测试数据，其中第一条的 create_time 取当前的系统时间，第二条的 create_time 比第一条多 5 分钟。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> ttl_table_v1 </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A000&#x27;</span>, now(), <span class="string">&#x27;C1&#x27;</span>, <span class="number">1</span>), </span><br><span class="line">       (<span class="string">&#x27;A000&#x27;</span>, now() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">5</span> <span class="keyword">MINUTE</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>然后马上进行查询（手速要快），然后等 10 秒过后（从写入数据的那一刻起），再查询一次。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829182030888-1275351927.png" alt="img"></p>
<p><strong>再次查询 ttl_table_v1 会看到，由于第一条数据满足 TTL 过期时间（当前系统时间 &gt;&#x3D; create_time + 10 秒），它们的 code 和 type 会被还原为数据类型的零值。</strong></p>
<p><strong>如果想要修改列字段的 TTL，或者为已有字段添加 TTL（不可以是主键字段），都可以使用 ALTER 语句，举个栗子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE ttl_table_v1 MODIFY COLUMN code String TTL create_time + INTERVAL 1 DAY</span><br></pre></td></tr></table></figure>

<p><strong>2）表级别设置 TTL</strong></p>
<p><strong>如果想为整张表设置 TTL，需要在 MergeTree 的表参数中增加 TTL 表达式，举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ttl_table_v2 (</span><br><span class="line">    id String,</span><br><span class="line">    create_time DateTime,</span><br><span class="line">    code String TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MINUTE</span>,</span><br><span class="line">    type UInt8</span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time</span><br><span class="line">TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br></pre></td></tr></table></figure>

<p><strong>ttl_table_v2 整张表被设置了 TTL，当触发 TTL 清理时，那些满足过期时间的数据行将被整行删除。同样，表级别的 TTL 也支持修改，方法如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE ttl_table_v2 MODIFY TTL create_time INTERVAL + 3 DAY</span><br></pre></td></tr></table></figure>

<p><strong>另外表级别的 TTL 也不支持取消。</strong></p>
<p><strong>3）TTL 运行机理</strong></p>
<p><strong>在了解了列级别和表级别 TTL 的运行机理后，现在简单聊一聊 TTL 的运行机理。如果一张 MergeTree 表被设置了 TTL 表达式，那么在写入数据时会以分区为单位，在每个分区目录内生成 ttl.txt 文件。以上面的 ttl_table_v2 为例，它被设置了列级别的 TTL，也被设置了表级别的 TTL，那么在写入数据之后，它的每个分区目录内都会生成 ttl.txt 文件。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829182020856-1939143318.png" alt="img"></p>
<p><strong>我们查看 ttl.txt 的内容发现，原来 MergeTree 是通过一串 JSON 保存了 TTL 的相关信息，其中：</strong></p>
<ul>
<li><code>columns 用于保存列级别的 TTL 信息</code></li>
<li><code>table 用于表级别的 TTL 信息</code></li>
<li><code>min 和 max 则保存了当前数据分区内，TTL 指定日期字段的最小值和最大值分别与 INTERVAL 表达式计算后的时间戳</code></li>
</ul>
<p><strong>如果将 table 属性中的 min 和 max 时间戳格式化，并分别与 create_time 最小值与最大值进行对比：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829182013609-1828101509.png" alt="img"></p>
<p><strong>则能够印证，ttl.txt 中记录的极值区间恰好等于当前分区内 create_time 的最小值、最大值加 1 天（86400 秒），与 TTL 表达式 create_time + INTERVAL 1 DAY 相符合，同理 ttl_min 和 ttl_max 分别减去一天即可得到 create_time 这一列的最小值和最大值。</strong></p>
<p><strong>在知道了 TTL 信息的记录方式之后，再来看看它的处理逻辑。</strong></p>
<ul>
<li><code>1. MergeTree 以分区目录为单位，通过 ttl.txt 文件记录过期时间，并将其作为后续的判断依据</code></li>
<li><code>2. 每当写入一批数据时，都会基于 INTERVAL 表达式的计算结果为这个分区生成 ttl.txt 文件</code></li>
<li><code>3. 只有 MergeTree 在对属于相同分区的多个分区目录进行合并时，才会触发删除 TTL 过期数据的逻辑</code></li>
<li><code>4. 在选择删除的分区时，会使用贪婪算法，它的算法规则是尽可能找到会最早过期的、同时年纪又是最老的分区（合并次数更多，MaxBlockNum 更大的）</code></li>
<li><code>5. 如果一个分区内某一列数据因为 TTL 到期全部被删除了，那么在合并之后生成的新分区目录中，将不会再包含该列对应的 bin 文件和 mrk 文件，如果列数据分开存储的话</code></li>
</ul>
<p><strong>TTL 默认的合并频率由 MergeTree 的 merge_with_ttl_timeout 参数所控制，默认为 86400 秒、也就是 1 天。它维护的是一个专有的 TTL 任务队列，有别于 MergeTree 的常规合并任务，这个值如果设置的过小，可能会带来性能损耗。当然除了被动触发 TTL 合并外，也可以使用 optimize 强制触发合并：</strong></p>
<ul>
<li><code>optimize TABLE table_name PARTITION 分区名：触发一个分区合并</code></li>
<li><code>optimize TABLE table_name FINAL：触发所有分区合并</code></li>
</ul>
<p><strong>最后，ClickHouse 虽然没有提供删除 TTL 的声明方法，但是提供了控制 TTL 合并任务的启停方法。</strong></p>
<ul>
<li><code>SYSTEM STOP/START TTL MERGES：控制全局 MergeTree 表启停</code></li>
<li><code>SYSTEM STOP/START TTL MERGES table_name：控制指定 MergeTree 启停</code></li>
</ul>
<h4 id="多路径存储策略"><a href="#多路径存储策略" class="headerlink" title="多路径存储策略"></a>多路径存储策略</h4><p><strong>在 ClickHouse 19.15 版本之前，MergeTree 只支持单路径存储，所有的数据都会被写入 config.xml 配置中的 path 指定的路径下。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829182004024-1343945799.png" alt="img"></p>
<p><strong>即使服务器挂载了多块磁盘，也无法有效利用这些存储空间。为了解决这个痛点，从 19.15 版本开始，MergeTree 实现了自定义存储策略的功能，支持以数据分区为最小移动单元，将分区目录写入多块磁盘目录。</strong></p>
<p><strong>而根据配置策略的不同，目前大致有三类存储策略。</strong></p>
<ul>
<li><strong>默认策略：MergeTree 原本的存储策略，无需任何配置，所有分区会自动保存到 config.xml 配置中 path 指定的路径下。</strong></li>
<li><strong>JBOD 策略：这种策略适合服务器挂载了多块磁盘，但没有做 RAID 的场景。JBOD 的全称是 Just a Bunch of Disks，它是一种轮询策略，每执行一次 INSERT 或者 MERGE，所产生的新分区会轮询写入各个磁盘。这种策略的效果类似于 RAID 0，可以降低单块磁盘的负载，在一定条件下能够增加数据并行读写的性能。如果单块磁盘发生故障，则会丢掉应用 JBOD 策略写入的这部分数据，但这又会造成数据丢失，因此我们还需要利用副本机制来保障数据的可靠性（副本机制后面说）。</strong></li>
<li><strong>HOT&#x2F;COLD 策略：这种策略适合服务器挂载了不同类型磁盘的场景，将存储磁盘分为 HOT 和 COLD 两类区域。HOT 区域使用 SSD 这类高性能存储媒介，注重存储性能；COLD 区域则使用 HDD 这类高容量存储媒介，注重存储经济性。数据在写入 MergeTree 之初，会在 HOT 区域创建分区目录用于保存数据，当分区数据大小累积到阈值时，数据会自动移动到 COLD 区域。而在每个区域的内部，也支持定义多个磁盘，所以在单个区域的写入过程中，也能应用 JBOD 策略。</strong></li>
</ul>
<p><strong>存储配置需要预先定义在 config.xml 配置文件中，由 storage_configuration 表示，而 storage_configuration 之下又分为 disks 和 policies 两组标签，分别表示磁盘与存储策略。格式如下：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">storage_configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">disks</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">disk_name_a</span>&gt;</span> <span class="comment">&lt;!-- 自定义磁盘名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/ch/data1<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">keep_free_space_bytes</span>&gt;</span>1073741824<span class="tag">&lt;/<span class="name">keep_free_space_bytes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk_name_a</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">disk_name_b</span>&gt;</span> <span class="comment">&lt;!-- 自定义磁盘名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/ch/data2<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">keep_free_space_bytes</span>&gt;</span>1073741824<span class="tag">&lt;/<span class="name">keep_free_space_bytes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk_name_b</span>&gt;</span>	</span><br><span class="line">    <span class="tag">&lt;/<span class="name">disks</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policie_name_a</span>&gt;</span> <span class="comment">&lt;!-- 自定义策略名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">volumes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">volume_name_a</span>&gt;</span>  <span class="comment">&lt;!-- 自定义卷名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disk</span>&gt;</span>disk_name_a<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disk</span>&gt;</span>disk_name_b<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">max_data_part_size_bytes</span>&gt;</span>disk_name_a<span class="tag">&lt;/<span class="name">max_data_part_size_bytes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">volume_name_a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">volumes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">move_factor</span>&gt;</span>0.2<span class="tag">&lt;/<span class="name">move_factor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policie_name_a</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">policie_name_b</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policie_name_b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">storage_configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解释一下里面标签的含义，首先是 disks 标签：</strong></p>
<ul>
<li><code>，必填项，必须全局唯一，表示磁盘的自定义名称，显然可以定义多块磁盘</code></li>
<li><code>，必填项，用于指定磁盘路径</code></li>
<li><code>：选填项，以字节为单位，用于定义磁盘的预留空间</code></li>
</ul>
<p><strong>然后是 policies 标签，在 policies 标签里面需要引用已经定义的 disks 磁盘，并且同样支持定义多个策略：</strong></p>
<ul>
<li><code>，必填项，必须全局唯一，表示策略的自定义名称</code></li>
<li><code>，必须填，比如全局唯一，表示卷的自定义名称</code></li>
<li><code>，必填项，用于关联  配置内的磁盘，可以声明多个 disk，MergeTree 会按照声明的顺序选择 disk</code></li>
<li><code>，选填项，以字节为单位，表示在这个卷的单个 disk 磁盘中，一个数据分区的最大分区阈值。如果当前分区的数据大小超过阈值，则之后的分区会写入下一个 disk 磁盘</code></li>
<li><code>，选填项，默认为 0.1，如果当前卷的可用空间小于 factor 因子，并且定义了多个卷，则数据会自动向下一个卷移动</code></li>
</ul>
<p><strong>1. JBOD 策略演示</strong></p>
<p><strong>注意：storage_configuration 在 config.xml 里面是没有的，我们需要手动加进去。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">storage_configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">disks</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">disk_hot1</span>&gt;</span> <span class="comment">&lt;!-- 自定义磁盘名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/root/hotdata1/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk_hot1</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">disk_hot2</span>&gt;</span> <span class="comment">&lt;!-- 自定义磁盘名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/root/hotdata2/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk_hot2</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">disk_cold</span>&gt;</span> <span class="comment">&lt;!-- 自定义磁盘名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/root/colddata/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">keep_free_space_bytes</span>&gt;</span>1073741824<span class="tag">&lt;/<span class="name">keep_free_space_bytes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk_cold</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">disks</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置存储策略，在 volumes 卷下面引用上面定义的两块磁盘，组成磁盘组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jbod_policies</span>&gt;</span> <span class="comment">&lt;!-- 自定义策略名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">volumes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jbod</span>&gt;</span>  <span class="comment">&lt;!-- 自定义卷名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disk</span>&gt;</span>disk_hot1<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disk</span>&gt;</span>disk_hot2<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">jbod</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">volumes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jbod_policies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">storage_configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>至此一个支持 JBOD 的存储策略就配置好了，但在正式应用之前我们还需要做一些准备工作。首先我们要将目录创建好，然后将路径授权，让 ClickHouse 用户拥有相应的读写权限：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@satori ~]<span class="comment"># mkdir hotdata1 hotdata2 colddata</span></span><br><span class="line">[root@satori ~]<span class="comment"># sudo chown clickhouse:clickhouse -R /root</span></span><br></pre></td></tr></table></figure>

<p><strong>由于存储配置不支持动态更新，为了使配置生效，还需要重启 ClickHouse 服务，直接 clickhouse restart 即可。重启之后可以查询系统表来验证配置是否生效：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181952844-2036224644.png" alt="img"></p>
<p><strong>通过 system.disks 系统表可以看到刚才声明的三块磁盘配置已经生效，接着验证配置策略：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181945403-153314088.png" alt="img"></p>
<p><strong>通过 system.storage_policies 系统表可以看到刚才配置的存储策略也已经生效了，现在创建一张 MergeTree 表，用于测试 jbod_policies 存储策略的效果。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181936302-1008011642.png" alt="img"></p>
<p><strong>在定义 MergeTree 数据表时，可以使用 storage_policy 配置项指定刚才的 jbod_policies 存储策略，注意：存储策略一旦设置，就不能再修改了。下面来测试一下效果：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181927735-1046606557.png" alt="img"></p>
<p><strong>可以看到第一块分区写入了第一块磁盘 disk_hot1，然后我们再来写入第二批数据，此时会创建第二个分区目录：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181919064-149165324.png" alt="img"></p>
<p><strong>插入数据之后再次查看分区系统表，可以看到第二个分区写入了第二块磁盘。最后再触发一次分区合并动作，生成一个合并后的新分区目录：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181911463-1216561303.png" alt="img"></p>
<p><strong>还是查询分区系统表，可以看到合并后生成的 all_1_2_1 分区再次写入了第一块磁盘 disk_hot1。</strong></p>
<p><strong>相信此时应该解释清除 JBOD 策略的工作方式了，在这个策略中，由多个磁盘组成一个磁盘组，即 volume 卷。每当生成一个新数据分区的时候，分区目录会依照 volume 卷中磁盘定义的顺序，依次轮询并写入各个磁盘。</strong></p>
<p><strong>2. HOT&#x2F;COLD 策略演示</strong></p>
<p><strong>现在介绍 HOT&#x2F;COLD 策略的使用方法，我们将 JBOD 策略对应的配置原封不动的拷贝过来，然后在里面加一个新策略。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">storage_configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">disks</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">disk_hot1</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/root/hotdata1/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk_hot1</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">disk_hot2</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/root/hotdata2/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk_hot2</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">disk_cold</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/root/colddata/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">keep_free_space_bytes</span>&gt;</span>1073741824<span class="tag">&lt;/<span class="name">keep_free_space_bytes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk_cold</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">disks</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jbod_policies</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">volumes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jbod</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">disk</span>&gt;</span>disk_hot1<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disk</span>&gt;</span>disk_hot2<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">jbod</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">volumes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jbod_policies</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 添加新策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">moving_from_hot_to_cold</span>&gt;</span>  <span class="comment">&lt;!-- 自定义策略名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">volumes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">hot</span>&gt;</span> <span class="comment">&lt;!-- 自定义名称，hot 区域磁盘 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disk</span>&gt;</span>disk_hot1<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">max_data_part_size_bytes</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">max_data_part_size_bytes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">hot</span>&gt;</span>        </span><br><span class="line">                <span class="tag">&lt;<span class="name">cold</span>&gt;</span> <span class="comment">&lt;!-- 自定义名称，cold 区域磁盘 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disk</span>&gt;</span>disk_cold<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">cold</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">volumes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">move_factor</span>&gt;</span>0.2<span class="tag">&lt;/<span class="name">move_factor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">moving_from_hot_to_cold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">storage_configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>用新配置将之前的 JBOD 配置给替换掉，或者直接将我们新加的部分添加到配置文件中即可，然后重启 ClickHouse。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181901836-1655234789.png" alt="img"></p>
<p><strong>可以看到新配置的存储策略已经生效了，moving_from_hot_to_cold 存储策略拥有 hot 和 cold 两个磁盘卷，在每个卷下各拥有一块磁盘。注意：hot 磁盘卷的 max_data_part_size 列显示的值为 1MB，这个值的含义为，在这个磁盘卷下，如果一个分区的大小超过 1MB，则它需要被移动到紧邻的下一个磁盘。当然这里为了演示效果，实际工作中不会配置的这么小的。</strong></p>
<p><strong>那么下面还是创建一张 MergeTree 表，用于测试 moving_from_hot_to_cold 存储策略的效果。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hot_cold_table (id UInt64)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">SETTINGS storage_policy <span class="operator">=</span> <span class="string">&#x27;moving_from_hot_to_cold&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>在定义 MergeTree 时，使用 storage_policy 配置项指定刚才定义的存储策略，当然存储策略一旦定义就不能再修改了。那么接下来就来测试一下效果，首先写入第一批数据（小于 1MB），创建一个分区目录：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181852306-1069889650.png" alt="img"></p>
<p><strong>查询分区系统表，可以看到第一个分区写入了 hot 卷。那么下面就来写入第二批数据，数据大小和上次一样，当然此时会创建第二个分区目录：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181842923-483729542.png" alt="img"></p>
<p><strong>这是我们看到第二个分区仍然写入了 hot 卷，因为 hot 卷的 max_data_part_size 是 1MB，而每次写入数据的大小没有超过 1MB，所以自然都保存到了该磁盘下。那么接下来触发一次分区的合并动作，会生成一个新的分区目录。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181835354-1979918308.png" alt="img"></p>
<p><strong>当两个分区合并之后，所创建的新分区的大小超过了 1MB，所以它会被写入 cold 卷。当然一次性写入大于 1MB 的数据，分区也会被写入 cold 卷。</strong></p>
<p><strong>至此我们算是明白了 HOT&#x2F;COLD 策略的工作方式了，在这个策略中，由多个磁盘卷（volume 卷）组成一个 volume 组。每当生成一个新数据分区的时候，按照阈值大小（max_data_part_size），分区目录会依照 volume 组中磁盘定义的顺序，依次轮询并写入各个卷下的磁盘。</strong></p>
<p><strong>另外，虽然 MergeTree 的存储策略是不能修改的，但分区目录却支持移动，例如将某个分区移动至当前存储策略中 volume 卷下的其它 disk 磁盘：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> hot_cold_table MOVE PART <span class="string">&#x27;all_1_2_1&#x27;</span> <span class="keyword">TO</span> DISK <span class="string">&#x27;disk_hot1&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>或者将某个分区移动至当前存储策略中其它的 volume 卷：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> hot_cold_table MOVE PART <span class="string">&#x27;all_1_2_1&#x27;</span> <span class="keyword">TO</span> VOLUME <span class="string">&#x27;cold&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181828118-1564848043.png" alt="img"></p>
<h3 id="ReplacingMergeTree"><a href="#ReplacingMergeTree" class="headerlink" title="ReplacingMergeTree"></a>ReplacingMergeTree</h3><p><strong>虽然 MergeTree 拥有主键，但是它的主键却没有唯一的约束，这意味着即便多行数据的主键相同，依旧能够正确写入。而在某些场合我们不希望数据表中有重复的数据，那么这个时候 ReplacingMergeTree 就登场了，它就是为数据去重而设计的，可以在合并分区时删除重复的数据。因此它的出现，确实在一定程度上解决了重复数据的问题，啊嘞嘞，为啥是一定程度？先卖个关子。</strong></p>
<p><strong>创建一张 ReplacingMergeTree 数据表的语法和创建普通 MergeTree 表别无二致，只需要将 ENGINE 换一下即可：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE = ReplacingMergeTree(ver)</span><br></pre></td></tr></table></figure>

<p><strong>里面的参数 ver 是选填的，可以指定一个整型、Date、DateTime 的字段作为版本号，这个参数决定了去除重复数据时所使用的算法。那么下面我们就来创建一张 ReplacingMergeTree 数据表：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> replace_table (</span><br><span class="line">    id String,</span><br><span class="line">    code String,</span><br><span class="line">    create_time DateTime</span><br><span class="line">) ENGINE <span class="operator">=</span> ReplacingMergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, code)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br></pre></td></tr></table></figure>

<p><strong>这里的 ORDER BY 是去除重复数据的关键，不是 PRIMARY KEY，ORDERR BY 声明的表达式是后续判断数据是否重复的依据。在这个栗子中，数据会基于 id 和 code 两个字段进行去重，我们写入几条数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> replace_table </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-10 15:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-11 15:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C100&#x27;</span>, <span class="string">&#x27;2020-11-12 15:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C200&#x27;</span>, <span class="string">&#x27;2020-11-13 15:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A002&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;2020-11-14 15:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A003&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>, <span class="string">&#x27;2020-11-15 15:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>我们插入了 6 条数据，但 create_time 为 2020-11-10 15:00:00、2020-11-11 15:00:00 的两条数据的 id 和 code 是重复的，因此会进行去重，只保留重复数据的最后一条，所以最终只会有 5 条数据。但需要注意的是，我们这 6 条数据是使用一个 INSERT 语句导入的，所以在导入的时候直接就去重了。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181813167-935728819.png" alt="img"></p>
<p><strong>我们看到只保留了最后一条重复数据，因为使用的是一个 INSERT，所以这批数据会写入到同一个分区目录。如果是同一分区的不同分区目录（分多批导入），那么数据是不会去重的，只有在进行合并的时候才会进行去重。举个栗子，我们再写入几条数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> replace_table </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-03 15:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-02 15:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>显然这两条数据会写入新的分区目录，但它们的 id 和 code 也是重复的，因此会去进行去重，最终新生成的分区目录中只会有一条数据。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181805763-97212981.png" alt="img"></p>
<p><strong>ClickHouse 的控制台做的还是很人性化的，不同分区目录的数据是分开显示的，当然我们在获取到的数据本身是连在一起的，只是 ClickHouse 的控制台方便你观察而分开显示了。我们看到第二个分区目录中只有一条数据，因为导入的两条数据的 id 和 code 是重复的，在写入同一个分区目录的时候会先对数据进行去重。但是不同分区目录的之间的数据是可以重复的，因为去重是以分区目录为单位的，而一个分区可以对应多个分区目录，所以上面出现了两个 A001、C1，因为它们位于不同的分区目录。只有当这些分区目录进行合并、生成新的分区目录时才会进行去重。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181759317-1132408541.png" alt="img"></p>
<p><strong>当不同分区目录的数据进行合并时，数据再次进行了去重，会保留后创建的分区目录中的数据，因此 create_time 为 2020-11-02 15:00:00 的数据保留了下来。并且我们也可以看到，ReplacingMergeTree 在去除重复数据时，确实是以排序键为单位的。如果以主键去重的话，那么就不会有 3 条 A001 了。</strong></p>
<p><strong>所以暂时可以得出如下结论：</strong></p>
<ul>
<li><code>1. 去重是以排序键为准</code></li>
<li><code>2. 当数据写入同一个分区目录时，会直接对重复数据进行去重，并且保留的是最后一条</code></li>
<li><code>3. 同一分区、但位于不同分区目录的数据不会进行去重，只有在合并成新的分区目录时才会进行去重，并且保留的是最后一个分区的数据</code></li>
</ul>
<p><strong>不过问题来了，要是不同分区的数据会不会去重呢？其实在开头我们就已经埋下伏笔了，因为我们在开头说了 ReplacingMergeTree 是在一定程度上解决了数据重复的问题，所以不同分区的数据重复它是无法解决的。</strong></p>
<p><strong>我们上面所有的数据都位于 2020-11 这个分区中，那么下面再插入一条数据、创建一个新的分区：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO replace_table VALUES (&#x27;A001&#x27;, &#x27;C1&#x27;, &#x27;2010-11-17 15:00:00&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>我们将 2020 改成 2010，然后测试一下：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181751295-1246488673.png" alt="img"></p>
<p><strong>因此不同分区的数据是无法进行去重的，这也算是 ReplacingMergeTree 的一个局限性。当然说局限性感觉也不是很合适，因为分区的目的就是为了减小查询时的数据量，如果往一个分区导入数据还要在乎其它分区、看数据是否在其它分区中已出现，那这不就相当于丧失了分区的意义了吗？</strong></p>
<p><strong>但是问题来了，这里不同分区的数据先不考虑，因为它无法去重，我们再谈一下同一个分区中数据去重的逻辑。我们说当数据重复时会保留最后一条，但有时我们希望某个字段的值最大的那一条保留下来，这时该怎么做呢？还记得我们之前说在指定 ReplacingMergeTree 的时候可以指定参数吗？</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> replace_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> replace_table (</span><br><span class="line">    id String,</span><br><span class="line">    code String,</span><br><span class="line">    create_time DateTime</span><br><span class="line">    <span class="comment">-- 指定参数，以后去重的时候会保留 create_time 最大的那一条数据</span></span><br><span class="line">) ENGINE <span class="operator">=</span> ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, code)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br></pre></td></tr></table></figure>

<p><strong>然后插入几条数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> replace_table </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-10 15:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-21 15:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-11 15:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>显示此时会保留 create_time 为 2020-11-21 15:00:00 的记录，因为的值最大，我们测试一下：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181742777-356270348.png" alt="img"></p>
<p><strong>然后再插入两条记录：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> replace_table </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-28 15:00:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> replace_table </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;2020-11-27 15:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：我们要分两批导入，然后进行合并，显然 2020-11-28 15:00:00 这条会保留下来，而不是最后一个分区目录中数据。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181736300-18731632.png" alt="img"></p>
<p><strong>所以最后再总结一下 ReplacingMergeTree 的使用逻辑：</strong></p>
<ul>
<li><code>1. 使用 ORDER BY 排序键作为判断数据重复的唯一键</code></li>
<li><code>2. 当导入同一分区目录时，会直接进行去重</code></li>
<li><code>3. 当导入不同分区目录时，不会进行去重，只有当分区目录合并时，属于同一分区内的重复数据才会去重；但是不同分区内的重复数据不会被删除</code></li>
<li><code>4. 在进行数据去重时，因为分区内的数据已经是基于 ORDER BY 排好序的，所以能很容易地找到那些相邻的重复的数据</code></li>
<li><code>5. 数据去重策略有两种：如果没有设置 ver 版本号，则保留同一组重复数据中的最后一条；如果设置了 ver 版本号，则保留同一组重复数据中 ver 字段取值最大的那一行</code></li>
</ul>
<h3 id="SummingMergeTree"><a href="#SummingMergeTree" class="headerlink" title="SummingMergeTree"></a>SummingMergeTree</h3><p><strong>假设有这样一种查询需求，终端用户只需要查询数据的汇总结果，不关心明细数据，并且数据的汇总条件是预先明确的（GROUP BY 条件明确，且不会随意改变）。对于这样的查询场景，ClickHouse 要如何解决呢？</strong></p>
<p><strong>最直接的方案就是使用 MergeTree 存储数据，然后通过 GROUP BY 聚合查询，并利用 SUM 函数汇总结果。这种方案本身完全行的通，但是有两个不完美之处：</strong></p>
<ul>
<li><code>存在额外的存储开销：终端用户不会查询任何明细数据，只关心汇总结果，所以不应该一直保存所有的明细数据</code></li>
<li><code>存在额外的查询开销：终端用户只关心汇总结果，虽然 MergeTree 性能强大，但是每次查询都进行实时聚合计算也是一种性能消耗</code></li>
</ul>
<p><strong>而 SummingMergeTree 就是为了应对这类查询场景而生的，顾名思义它能够在合并分区的时候按照预先定义的的条件汇总数据，将同一分组下的多行数据汇总成一行，这样既减少了数据行，又降低了后续汇总查询的开销。</strong></p>
<p><strong>在之前我们说过，MergeTree 的每个分区内，数据都会按照 ORDER BY 表达式排好序，主键索引都会按照 PRIMARY KEY 取值并排好序。而默认情况下 ORDER BY 可以代指 PRIMARY KEY，所以一般情况下我们只需要声明 ORDER BY 即可。但如果需要同时定义 ORDER BY 和 PRIMARY KEY，通常只有一种可能，那就是明确希望 ORDER BY 和 PRIMARY KEY 不同，而这种情况只会在使用 SummingMergeTree 和 AggregatingMergeTree 时才会出现，因为这两者的聚合都是根据 ORDER BY 进行的。</strong></p>
<p><strong>假设有一张 SummingMergeTree 数据表，里面有 A、B、C、D、E、F 六个字段，如果需要按照 A、B、C、D 汇总，那么在创建表结构的时候需要指定：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (A, B, C, D)</span><br></pre></td></tr></table></figure>

<p><strong>但是这样主键也被定义成了 A、B、C、D，而在业务层面其实只需要对业务字段 A 进行查询过滤，所以应该只使用 A 字段创建主键。所以我们应该这么定义：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (A, B, C, D)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY A</span><br></pre></td></tr></table></figure>

<p><strong>但如果同时声明了 ORDER BY 和 PRIMARY KEY，那么 MergeTree 会强制要求 PRIMARY KEY 必须是 ORDER BY 的前缀，所以：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不行</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (B, C)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY A</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 行</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (B, C)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY B</span><br></pre></td></tr></table></figure>

<p><strong>这种强制约束保障了即便在定义不同的情况下，主键仍然是排序键的前缀，不会出现索引与数据顺序混乱的问题。假设现在业务发生了细微的变化，需要减少字段，将先前的 A、B、C、D 改为按照 A、B 汇总，则可按照如下方式修改排序键：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name MODIFY ORDER BY (A, B)</span><br></pre></td></tr></table></figure>

<p><strong>但是需要注意，如果减少字段的话，只能从右往左减少。怎么理解呢？我们之前是按照 A、B、C、D 进行的汇总，那么减少字段的话，最终可以按照 A、B、C 汇总、可以按照 A、B 汇总、可以按照 A 汇总，但是不能按照 A、C 或者 A、D、或者 A、C、D 等等进行汇总。所以减少字段一定是从右往左依次减少，不能出现跳跃。</strong></p>
<p><strong>除此之外，ORDER BY 只能在现有字段的基础上减少字段，如果新增字段，则只能添加通过 ALTER ADD COLUMN 新增的字段。但 ALTER 是一种元数据级别的操作，修改成本很低，相比不能修改的主键，已经非常便利了。</strong></p>
<p><strong>那么介绍 SummingMergeTree 数据表的创建方式，显然都已经猜到了，因为 MergeTree 家族的表引擎创建方式都是类似的，只不过引擎不同罢了。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE <span class="operator">=</span> SummingMergeTree((col1, col2, col3, ...))</span><br></pre></td></tr></table></figure>

<p><strong>其中 col1、col2 为 columns 参数值，这是一个选填参数，用于设置除主键外的其它数值类型字段，以指定被 SUM 汇总的列字段。如果不填写此参数，则会将所有非主键的数值类型字段进行汇总，下面就来创建一张 SummingMergeTree 表：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> summing_table (</span><br><span class="line">    id String,</span><br><span class="line">    city String,</span><br><span class="line">    v1 UInt32,</span><br><span class="line">    v2 Float64,</span><br><span class="line">    create_time DateTime</span><br><span class="line">) ENGINE <span class="operator">=</span> SummingMergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, city)</span><br></pre></td></tr></table></figure>

<p><strong>接下来插入几条数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> summing_table</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, <span class="number">10</span>, <span class="number">20.1</span>, <span class="string">&#x27;2020-05-10 17:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, <span class="number">20</span>, <span class="number">30.2</span>, <span class="string">&#x27;2020-05-20 17:00:00&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;shanghai&#x27;</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="string">&#x27;2020-05-10 17:00:00&#x27;</span>);</span><br><span class="line">       </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> summing_table</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;2020-05-01 17:00:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> summing_table</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="string">&#x27;2020-10-10 17:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>显然此时会创建三个分区目录，202005_1_\1_0、202005_2_\2_0、202010_1_\1_0。另外 SummingMergeTree 和 ReplacingMergeTree 类似，如果导入同一分区目录的数据有重复的，那么直接就聚合了，不同分区目录则不会聚合，而是在合并生成新分区目录的时候，再对属于同一分区的多个分区目录里的数据进行聚合。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181722193-2107011356.png" alt="img"></p>
<p><strong>我们看到第一个分区目录中的三条数据聚合成了两条，然后手动触发合并动作：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181715636-1448937195.png" alt="img"></p>
<p><strong>不同分区目录（属于同一分区）里的数据聚合在一起了，至于不在汇总字段之列的 create_time 则取了同组内第一行数据的值；而不同分区对应的分区目录就不会被聚合了，因为不在同一个分区内。</strong></p>
<p><strong>另外 SummingMergeTree 也支持嵌套类型的字段，在使用嵌套类型字段时，需要被 SUM 汇总的字段必须以以 Map 后缀结尾，例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> summing_table_nested (</span><br><span class="line">    id String,</span><br><span class="line">    nestMap Nested (</span><br><span class="line">        id UInt32,</span><br><span class="line">        key UInt32,</span><br><span class="line">        val UInt64</span><br><span class="line">    ),</span><br><span class="line">    create_time DateTime</span><br><span class="line">) ENGINE <span class="operator">=</span> SummingMergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>

<p><strong>在使用嵌套数据类型时，默认会以嵌套类型中第一个字段作为聚合条件 Key，写入测试数据：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181705340-308252351.png" alt="img"></p>
<p><strong>我们看到写入的时候就聚合了，并且按照 nestMap 里面的 id 聚合的，之前我们说过：嵌套类型本质是一种多维数组的结构，里面的每个字段都是一个数组，并且长度要相等。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181659994-1690687124.png" alt="img"></p>
<p><strong>然后我们再写一条数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> summing_table_nested <span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, [<span class="number">2</span>], [<span class="number">300</span>], [<span class="number">600</span>], <span class="string">&#x27;2020-08-10 17:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>显然此时会新创建一个分区目录，然后我们手动触发合并：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181654283-926470290.png" alt="img"></p>
<p><strong>合并的结果显然符合我们的预期，当然如果分区不同，那么就无法合并了。</strong></p>
<p><strong>当然我们上面默认是按 id 进行聚合的，或者说是按嵌套类型中的第一个字段进行聚合，但 ClickHouse 也支持使用复合字段（Key）作为数据聚合的条件。为了使用复合 Key，在嵌套类型的字段中，除了第一个字段以外，任何名称是以 Key、Id 或者 Type 结尾的字段，都将和第一个字段一起组成复合 Key。例如我们将上面的建表逻辑改一下，将小写 key 改成大写 Key：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> summing_table_nested (</span><br><span class="line">    id String,</span><br><span class="line">    nestMap Nested (</span><br><span class="line">        id UInt32,</span><br><span class="line">        Key UInt32,  <span class="comment">-- 大写 Key</span></span><br><span class="line">        val UInt64</span><br><span class="line">    ),</span><br><span class="line">    create_time DateTime</span><br><span class="line">) ENGINE <span class="operator">=</span> SummingMergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>

<p><strong>该栗子中会以 id 和 Key 作为聚合条件，因此以上就是 SummingMergeTree，我们再来总结一下它的处理逻辑：</strong></p>
<ul>
<li><code>只有 ORDER BY 排序键作为聚合数据的条件 Key</code></li>
<li><code>写入同一分区目录的数据会聚合之后在写入，而属于同一分区的不同分区目录的数据，则会在合并触发时进行汇总</code></li>
<li><code>不同分区的数据不会汇总到一起</code></li>
<li><code>如果在定义引擎时指定了 columns 汇总列（非主键的数值类型字段），则 SUM 会汇总这些列字段；如果未指定，则聚合所有非主键的数值类型字段</code></li>
<li><code>在进行数据汇总时，因为分区内的数据已经基于 ORDER BY 进行排序，所以很容易找到相邻也拥有相同 Key 的数据</code></li>
<li><code>在汇总数据时，同一分区内相同聚合 key 的多行数据会合并成一行，其中汇总字段会进行 SUM 计算；对于那些非汇总字段，则会使用第一行数据的取值</code></li>
<li><code>支持嵌套结构，但列字段名称必须以 Map 后缀结尾，并且默认以第一个字段作为聚合 Key。并且除了第一个字段以外，任何名称以 key、Id 或者 Type 为后缀结尾的字段都会和第一个字段组成复合 Key</code></li>
</ul>
<h3 id="AggregatingMergeTree"><a href="#AggregatingMergeTree" class="headerlink" title="AggregatingMergeTree"></a>AggregatingMergeTree</h3><p><strong>有过数仓建设经验的你一定知道数据立方体的概念，这是一个在数仓领域十分常见的模型，它通过以空间换时间的方式提升查询性能，将需要聚合的数据预先计算出来（预聚合）并保存，在后续需要聚合查询到的时候，直接使用保存好的结果数据。</strong></p>
<blockquote>
<p><strong>Kylin 就是一个典型的使用预聚合的数据仓库，提供 Hadoop&#x2F;Spark 之上的 SQL 查询接口及多维分析（OLAP）能力以支持超大规模数据。它的核心逻辑就是在数据集上定义一个星形模型或者雪花模型，然后基于模型搭建数据立方体（cube）并将结果存储在 HBase 中，最后使用标准 SQL 以及其它 API 进行查询，由于数据已经提前计算好，所以仅需亚秒级响应时间即可获得查询结果。</strong></p>
</blockquote>
<p><strong>AggregatingMergeTree 就有些数据立方体的意思，它能够在合并分区的时候按照预先定义的条件聚合数据。同时，根据预先定义的聚合函数计算数据并通过二进制的格式存入表内。通过将同一分组下的多行数据预先聚合成一行，既减少了数据行，又降低了后续聚合查询的开销。可以说 AggregatingMergeTree 是 SummingMergeTree 的升级版，它们的许多设计思路和特性是一致的，例如同时定义 ORDER BY 和 PRIMARY KEY 的原因和目的。但是在用法上两者存在明显差异，应该说 AggregatingMergeTree 的定义方式是 MergeTree 家族中最为特殊的一个。声明使用 AggregatingMergeTree 的方式如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE = AggregatingMergeTree()</span><br></pre></td></tr></table></figure>

<p><strong>AggregatingMergeTree 没有任何额外的设置参数，在分区合并时，在每个数据分区内，会按照 ORDER BY 聚合。而使用何种聚合函数，以及针对哪些列字段进行计算，则是通过定义 AggregateFunction 数据类型实现的。以下面的语句为例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> agg_table (</span><br><span class="line">    id String,</span><br><span class="line">    city String,</span><br><span class="line">    code AggregateFunction(uniq, String),</span><br><span class="line">    <span class="keyword">value</span> AggregateFunction(sum, UInt32),</span><br><span class="line">    create_time DateTime</span><br><span class="line">) ENGINE <span class="operator">=</span> AggregatingMergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, city)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id </span><br></pre></td></tr></table></figure>

<p><strong>上述的 id 和 city 是聚合条件，等同于在 SQL 语句中指定 GROUP BY id, city；而 code 和 value 聚合字段，其语义等同于 uniq(code)、sum(value)。</strong></p>
<p><strong>AggregateFunction 是 ClickHouse 提供的一种特殊的数据结构，它能够以二进制的形式存储中间状态结果。其使用方法也十分特殊，对于 AggregateFunction 类型的列字段，数据的查询和写入都与众不同。在写入数据时需要调用 *State 函数，查询数据时则调用相应的 *Merge 函数。其中 * 表示定义时使用的聚合函数，例如上面的建表语句中使用了 uniq 和 sum 函数。</strong></p>
<p><strong>那么在写入数据时，需要调用对应的 uniqState 和 sumState 函数，并使用 INSERT SELECT 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> agg_table </span><br><span class="line"><span class="keyword">SELECT</span> (<span class="string">&#x27;A000&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, uniqState(<span class="string">&#x27;code1&#x27;</span>), sumState(toUInt32(<span class="number">100</span>)), <span class="string">&#x27;2020-08-10 17:00:00&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;A000&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, uniqState(<span class="string">&#x27;code1&#x27;</span>), sumState(toUInt32(<span class="number">100</span>)), <span class="string">&#x27;2020-08-10 17:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>而在查询数据时，如果使用列名 code、value 进行访问的话，虽然也能查询到数据，只不过显示的是无法阅读的二进制，我们需要调用对应的 uniqMerge 和 sumState 函数。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, city, uniqMerge(code), sumMerge(<span class="keyword">value</span>)</span><br><span class="line"><span class="keyword">FROM</span> agg_table </span><br><span class="line"><span class="comment">-- 在 SQL 语句中聚合语句肯定要用 GROUP BY</span></span><br><span class="line"><span class="comment">-- 但在定义表结构的时候，聚合字段是使用 ORDER BY 表示的，当然它指定的也是排序字段</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id, city</span><br></pre></td></tr></table></figure>

<p><strong>下面来测试一下：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181639262-723234817.png" alt="img"></p>
<p><strong>看到这里你可能觉得 AggregatingMergeTree 使用起来有些过去繁琐了，连正常数据写入还要借助 INSERT SELECT、并且调用特殊函数才能实现，没错，如果是上面这种做法的话，确实有些麻烦了。不过无须担心，当前这种用法并不是主流用法。</strong></p>
<p><strong>AggregatingMergeTree 的主流用法是结合物化视图使用，将它作为物化视图的表引擎，这里的物化视图是作为其它数据表上层的一种查询视图。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181631184-1254707137.png" alt="img"></p>
<p><strong>接下来用一组示例进行说明，首先创建明细数据表，也就是俗称的底表：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> agg_table_basic (</span><br><span class="line">    id String,</span><br><span class="line">    city String,</span><br><span class="line">    code String,</span><br><span class="line">    <span class="keyword">value</span> UInt32</span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> city</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, city)</span><br></pre></td></tr></table></figure>

<p><strong>通常使用 MergeTree 作为底表，用于存储全量的明细数据，并以此对外提供实时查询。接着，创建一张物化视图：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> agg_view </span><br><span class="line">ENGINE <span class="operator">=</span> AggregatingMergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> city</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, city)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span></span><br><span class="line">    id, city,</span><br><span class="line">    uniqState(code) <span class="keyword">AS</span> code,</span><br><span class="line">    sumState(<span class="keyword">value</span>) <span class="keyword">AS</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">FROM</span> agg_table_basic</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id, city</span><br></pre></td></tr></table></figure>

<p><strong>物化视图使用 AggregatingMergeTree 表引擎，用于特定场景的数据查询，相比 MergeTree，它拥有更高的性能。但在新增数据时，面向的对象是底表 MergeTree：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> agg_table_basic </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A000&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;code1&#x27;</span>, <span class="number">100</span>),</span><br><span class="line">       (<span class="string">&#x27;A000&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;code2&#x27;</span>, <span class="number">200</span>),</span><br><span class="line">       (<span class="string">&#x27;A000&#x27;</span>, <span class="string">&#x27;shanghai&#x27;</span>, <span class="string">&#x27;code1&#x27;</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p><strong>数据会自动同步到物化视图，并按照 AggregatingMergeTree 的引擎的规则进行处理。而在查询数据时，面向的对象是物化视图 AggregatingMergeTree：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181622930-228367562.png" alt="img"></p>
<p><strong>以上就是 AggregatingMergeTree 的整个流程，最常见的用法是作为普通物化视图的表引擎，和普通 MergeTree 数据表搭配使用。</strong></p>
<h3 id="CollapsingMergeTree"><a href="#CollapsingMergeTree" class="headerlink" title="CollapsingMergeTree"></a>CollapsingMergeTree</h3><p><strong>假设现在需要设计一款数据库，该数据库支持需要支持对已经存在的数据实现行级粒度的修改和删除，你会怎么设计呢？一种最常见的想法是：首先找到保存数据的文件，接着修改这个文件，比如修改或删除那些需要变化的数据行。然而在大数据领域，对于 ClickHouse 这类高性能分析数据库而言，对数据源文件进行修改是一件非常奢侈且代价昂贵的操作。相较于直接修改源文件，将修改和删除操作转换为新增操作会更合适一些，也就是以增代删。</strong></p>
<p><strong>CollapsingMergeTree 就是一种通过以增代删的思路，支持行级数据修改和删除的表引擎。它通过定义一个 sign 标记位字段，记录数据行的状态。如果 sign 标记为 1，则表示这是一行有效数据；如果 sign 标记为 -1，则表示这行数据要被删除。当 CollapsingMergeTree 分区合并时，同一数据分区内，sign 标记为 1 和 -1 的一组数据（ORDER BY 字段对应的值相同）会被抵消删除。这种 1 和 -1 相互抵消的操作，犹如将一张瓦楞纸折叠了一般，这种直观的比喻，想必也是折叠合并树（CollapsingMergeTree）的由来。</strong></p>
<p><strong>声明 CollapsingMergeTree 的方式如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE = CollapsingMergeTree(sign)</span><br></pre></td></tr></table></figure>

<p><strong>其中，sign 用于指定一个 Int8 类型的标志位字段，一个完整的 CollapsingMergeTree 数据表声明如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> collapse_table (</span><br><span class="line">    id String,</span><br><span class="line">    code Int32,</span><br><span class="line">    create_time DateTime,</span><br><span class="line">    sign Int8</span><br><span class="line">) ENGINE <span class="operator">=</span> CollapsingMergeTree(sign)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>

<p><strong>与其它的 MergeTree 变种引擎一样，CollapsingMergeTree 同样是以 ORDER BY 排序键作为后续判断数据唯一性的依据。按照之前的介绍，对于上述 collapse_table 数据表而言，除了常规的新增操作之外，还能支持其它两种操作：</strong></p>
<p><strong>其一：删除一行数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入一条数据，后续对它进行删除</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A000&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>删除一条数据，显然不能像关系型数据库那样使用 DELETE，正确做法是插入一条”要删除的数据”的镜像数据，ORDER BY 字段与原数据相同（其它字段可以不同），然后 sign 取反为 -1，它会和原数据折叠，然后相互抵消。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A000&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>测试一下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">satori :) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> collapse_table</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> collapse_table</span><br><span class="line"></span><br><span class="line">Query id: f02e3e84<span class="number">-7837</span><span class="number">-4</span>db7<span class="operator">-</span>af2b<span class="operator">-</span>d42957c5a63b</span><br><span class="line"></span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A000 │  <span class="number">100</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │    <span class="number">1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A000 │  <span class="number">100</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │   <span class="number">-1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure>

<p><strong>其二：修改一行数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入一条数据，后续对它进行修改</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>其中 code 的值是 100，我们要将其修改成 120，该怎么做呢？显然不能像关系型数据那样使用 UPDATE，正确的做法是以增代删。先创建镜像数据将原数据折叠，然后将修改后的原数据再插入到表中即可。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> collapse_table </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">-1</span>),</span><br><span class="line">       <span class="comment">-- 然后将原数据修改之后作为新数据，插入到表中，sign 为 1</span></span><br><span class="line">       (<span class="string">&#x27;A001&#x27;</span>, <span class="number">120</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>测试一下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">satori :) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> collapse_table</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> collapse_table</span><br><span class="line"></span><br><span class="line">Query id: bfb8afec<span class="operator">-</span>e672<span class="number">-416</span>f<span class="operator">-</span>a7b8<span class="number">-5</span>fcdf6470e59</span><br><span class="line"></span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A000 │  <span class="number">100</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │    <span class="number">1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A000 │  <span class="number">100</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │   <span class="number">-1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A001 │  <span class="number">100</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │    <span class="number">1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A001 │  <span class="number">100</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │   <span class="number">-1</span> │</span><br><span class="line">│ A001 │  <span class="number">120</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │    <span class="number">1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.003</span> sec. </span><br><span class="line"></span><br><span class="line">satori :) </span><br></pre></td></tr></table></figure>

<p><strong>还是很好理解的，然后 CollapsingMergeTree 在折叠数据时遵循如下规则：</strong></p>
<ul>
<li><code>如果 sign = 1 比 sign = -1 的数据多一行，则保留最后一行 sign = 1 的数据</code></li>
<li><code>如果 sign = -1 比 sign = 1 的数据多一行，则保留第一行 sign = -1 的数据</code></li>
<li><code>如果 sign = 1 和 sign = -1 的数据行一样多，并且最后一行是 sign = 1，则保留第一行 sign = -1 和最后一行 sign = 1 的数据</code></li>
<li><code>如果 sign = 1 和 sign = -1 的数据行一行多，并且最后一行是 sign = -1，则什么也不保留</code></li>
<li><code>其余情况，ClickHouse 会打印告警日志，但不会报错，在这种情形下打印结果不可预知</code></li>
</ul>
<p><strong>当然折叠数据并不是实时触发的，和所有的其它 MergeTree 变种表引擎一样，这项特性只有在多个分区目录合并的时候才会触发，触发时属于同一分区的数据会进行折叠。而在分区合并之前，用户还是可以看到旧数据的，就像上面演示的那样。</strong></p>
<p><strong>如果不想看到旧数据，那么可以在聚合的时候可以改变一下策略：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原始 SQL 语句</span></span><br><span class="line"><span class="keyword">SELECT</span> id, <span class="built_in">sum</span>(code), <span class="built_in">count</span>(code), <span class="built_in">avg</span>(code), uniq(code) </span><br><span class="line"><span class="keyword">FROM</span> collapse_table <span class="keyword">GROUP</span> <span class="keyword">BY</span> id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改成如下</span></span><br><span class="line"><span class="keyword">SELECT</span> id, <span class="built_in">sum</span>(code <span class="operator">*</span> sign), <span class="built_in">count</span>(code <span class="operator">*</span> sign), <span class="built_in">avg</span>(code <span class="operator">*</span> sign), uniq(code <span class="operator">*</span> sign)</span><br><span class="line"><span class="keyword">FROM</span> collapse_table <span class="keyword">GROUP</span> <span class="keyword">BY</span> id <span class="keyword">HAVING</span> <span class="built_in">sum</span>(sign) <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>或者在查询数据之前使用 optimize TABLE table_name FINAL 命令强制分区合并，但是这种方法效率极低，在实际生产环境中慎用。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">satori :) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> collapse_table</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> collapse_table</span><br><span class="line"></span><br><span class="line">Query id: <span class="number">0</span>cf9d813<span class="number">-5</span>dcc<span class="number">-4</span>a58<span class="operator">-</span>a02a<span class="operator">-</span>de3d6fb38c60</span><br><span class="line"></span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A001 │  <span class="number">120</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │    <span class="number">1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line">satori :) </span><br></pre></td></tr></table></figure>

<p><strong>我们看到 A000 的数据已经没有了，只剩下了 A001，并且 code 是 120，不是原来的 100。</strong></p>
<p><strong>另外只有相同分区内的数据才有可能被折叠，不过这项限制对于 CollapsingMergeTree 来说通常不是问题，因为修改或删除数据的时候，这些数据的分区规则通常都是一致的，并不会改变。但 CollapsingMergeTree 还有一个非常致命的限制，那就是对数据的写入顺序有着严格要求，举个例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先写入 sign = 1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A002&#x27;</span>, <span class="number">102</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">-- 先写入 sign = -1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A002&#x27;</span>, <span class="number">102</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>显然此时是可以正常折叠的，我们刚才已经实验过了，但如果将写入的顺序置换一下，就无法折叠了。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先写入 sign = 1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A003&#x27;</span>, <span class="number">102</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 先写入 sign = -1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A003&#x27;</span>, <span class="number">102</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>我们测试一下，执行 optimize TABLE collapse_table FINAL，然后进行查询：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">satori :) <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> collapse_table</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> collapse_table</span><br><span class="line"></span><br><span class="line">Query id: <span class="number">3</span>aaf02d2<span class="number">-7089</span><span class="number">-42</span>f6<span class="number">-9</span>d3b<span class="operator">-</span>a697b196bd42</span><br><span class="line"></span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A001 │  <span class="number">120</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │    <span class="number">1</span> │</span><br><span class="line">│ A003 │  <span class="number">102</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │   <span class="number">-1</span> │</span><br><span class="line">│ A003 │  <span class="number">102</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │    <span class="number">1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line">satori :) </span><br></pre></td></tr></table></figure>

<p><strong>我们看到两个 A003 没办法进行折叠，原因就是这两条数据的 sign &#x3D; -1 在前、sign &#x3D; 1 在后，如果我们在写入一条 A003、sign &#x3D; -1 会有什么结果呢？显然会和 sign &#x3D; 1 的 A003 进行合并，只留下一条 sign &#x3D; -1 的 A003。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">satori :) <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> collapse_table</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> collapse_table</span><br><span class="line"></span><br><span class="line">Query id: <span class="number">82226926</span><span class="number">-6</span>f2a<span class="number">-4</span>ab8<span class="number">-80</span>b4<span class="operator">-</span>ce8980ec1eec</span><br><span class="line"></span><br><span class="line">┌─id───┬─code─┬─────────create_time─┬─sign─┐</span><br><span class="line">│ A001 │  <span class="number">120</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │    <span class="number">1</span> │</span><br><span class="line">│ A003 │  <span class="number">102</span> │ <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │   <span class="number">-1</span> │</span><br><span class="line">└──────┴──────┴─────────────────────┴──────┘</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line">satori :) </span><br></pre></td></tr></table></figure>

<p><strong>这种现象是 CollapsingMergeTree 的处理机制所导致的，因为它要求 sign &#x3D; 1 和 sign &#x3D; -1 的数据相邻，而分区内的数据严格按照 ORDER BY 排序，要实现 sign &#x3D; 1 和 sign &#x3D; -1 的数据相邻，则只能严格按照顺序写入。</strong></p>
<p><strong>如果数据的写入顺序是单线程执行的，则能够比较好的控制写入顺序；但如果需要处理的数据量很大，数据的写入程序通常是多线程的，那么此时就不能保障数据的写入顺序了。而在这种情况下，CollapsingMergeTree 的工作机制就会出现问题，而为了解决这个问题，ClickHouse 额外提供了一个名为 VersionedCollapsingMergeTree 的表引擎。</strong></p>
<h3 id="VersionedCollapsingMergeTree"><a href="#VersionedCollapsingMergeTree" class="headerlink" title="VersionedCollapsingMergeTree"></a>VersionedCollapsingMergeTree</h3><p><strong>VersionedCollapsingMergeTree 表引擎的作用和 CollapsingMergeTree 完全相同，它们的不同之处在于 VersionedCollapsingMergeTree 对数据的写入顺序没有要求，在同一个分区内，任意顺序的数据都可以完成折叠操作。那么 VersionedCollapsingMergeTree 是如何做到这一点的呢？其实从它的名字就能看出来，因为相比 CollapsingMergeTree 多了一个 Versioned，那么显然就是通过版本号（version）解决的。</strong></p>
<p><strong>在定义 VersionedCollapsingMergeTree 数据表的时候，除了指定 sign 标记字段之外，还需要额外指定一个 UInt8 类型的 ver 版本号字段。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE = VersionedCollapsingMergeTree(sign, ver)</span><br></pre></td></tr></table></figure>

<p><strong>一个完整的 VersionedCollapsingMergeTree 表定义如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ver_collapse_table (</span><br><span class="line">    id String,</span><br><span class="line">    code Int32,</span><br><span class="line">    create_time DateTime,</span><br><span class="line">    sign Int8,</span><br><span class="line">    ver UInt8</span><br><span class="line">) ENGINE <span class="operator">=</span> CollapsingMergeTree(sign, ver)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>

<p><strong>那么 VersionedCollapsingMergeTree 是如何使用版本号字段的呢？其实很简单，在定义 ver 字段之后，VersionedCollapsingMergeTree 会自动将 ver 作为排序条件并增加到 ORDER BY 的末端。以上面的 ver_collapse_table 为例，在每个分区内，数据会按照 ORDER BY id, ver DESC 排序。所以无论写入时数据的顺序如何，在折叠处理时，都能回到正确的顺序。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先是删除数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ver_collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A000&#x27;</span>, <span class="number">101</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ver_collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A000&#x27;</span>, <span class="number">101</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 然后是修改数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ver_collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="number">101</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ver_collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="number">102</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ver_collapse_table <span class="keyword">VALUES</span> (<span class="string">&#x27;A001&#x27;</span>, <span class="number">103</span>, <span class="string">&#x27;2020-02-20 00:00:00&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>以上数据均能正常折叠。</strong></p>
<h3 id="各种-MergeTree-之间的关系总结"><a href="#各种-MergeTree-之间的关系总结" class="headerlink" title="各种 MergeTree 之间的关系总结"></a>各种 MergeTree 之间的关系总结</h3><p><strong>经过上述介绍是不是觉得 MergeTree 特别丰富呢？但还是那句话，任何事都有两面性，功能丰富就意味着很容易被这么多表引擎弄晕，那么下面我们就以继承和组合这两种关系来理解整个 MergeTree。</strong></p>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p><strong>首先为了便于理解，可以使用继承关系来理解 MergeTree，MergeTree 表引擎向下派生出 6 个变种表引擎。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181601134-545853463.png" alt="img"></p>
<p><strong>在 ClickHouse 底层的实现方法中，上述 7 种表引擎的区别主要体现在 Merge 合并的逻辑部分，简化后的对象关系如下图所示：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181553869-189950708.png" alt="img"></p>
<p><strong>可以看到在具体的实现部分，7 种 MergeTree 共用一个主体，而在触发 Merge 动作时，它们调用了各自独有的合并逻辑。</strong></p>
<p><strong>MergeTree 之外的其它 6 个变种表引擎的 Merge 合并逻辑，全部都是建立在 MergeTree 基础之上的，且均继承于 MergeTree 的 MergingSortedBlockInputStream，如下图所示：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181548211-180815683.png" alt="img"></p>
<p><strong>MergingSortedBlockInputStream 的主要作用是按照 ORDER BY 的规则保证分区内数据的有序性，而其它 6 种变种 MergeTree 的合并逻辑，则是在有序的基础之上各有所长，例如将排序后相邻的重复数据消除，或者将重复数据累加汇总等等。</strong></p>
<h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p><strong>了解完 7 种 MergeTree 的关系，下面再来说一下它们的组合，我们说如果 MergeTree 加上 Replicated 的话，则表示支持副本，那么 ReplicatedMergeTree 和普通的 MergeTree 有什么区别呢？</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181542392-1496501780.png" alt="img"></p>
<p><strong>上图中的虚线框部分是 MergeTree 的能力边界，而 ReplicatedMergeTree 则在 MergeTree 能力的基础之上增加了分布式协同的能力，其借助 zookeeper 的消息日志广播功能，实现了副本实例之间的数据同步功能。</strong></p>
<p><strong>ReplicatedMergeTree 系列可以用组合关系来理解，如下图所示：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/1229382-20210829181537938-2135925933.png" alt="img"></p>
<p><strong>当我们为 7 种 MergeTree 加上 Replicated 前缀之后，又能组合出 7 种新的表引擎，而这些 ReplicatedMergeTree 拥有副本协同的能力。关于 ReplicatedMergeTree，后续会详细说。</strong></p>
<p><strong>以上我们就介绍完了 MergeTree 以及整个家族系列的表引擎，MergeTree 系列表引擎在生产中是使用频率最高的表引擎，我们是非常有必要彻底掌握它的。但我们说除了 MergeTree，还有很多其它表引擎，虽然使用频率不是那么高，不过还是有适合自身的场景的，所以我们也需要掌握，那么后续就来看一看其它种类的表引擎。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hesay.cn">wenwen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hesay.cn/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/">https://hesay.cn/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hesay.cn" target="_blank">热心市民温温</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ClickHouse/">ClickHouse</a></div><div class="post_share"><div class="social-share" data-image="/img/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/11/ClickHouse%20%E5%85%B6%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%20(%E5%8D%81%E4%BA%94)/" title="ClickHouse 其它的一些操作函数 (十五)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ClickHouse 其它的一些操作函数 (十五)</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/11/ClickHouse%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0(%E5%8D%81%E4%BA%8C)/" title="ClickHouse 字符串的相关操作函数(十二)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ClickHouse 字符串的相关操作函数(十二)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0(%E5%8D%81%E4%B8%80)/" title="ClickHouse 中的常用聚合函数(十一)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中的常用聚合函数(十一)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中其它常见的表引擎(八)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E%EF%BC%9AMergeTree%20%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E5%85%AD)/" title="ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/" title="ClickHouse 中的数据查询以及各种子句(九)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中的数据查询以及各种子句(九)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E5%85%B6%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%20(%E5%8D%81%E4%BA%94)/" title="ClickHouse 其它的一些操作函数 (十五)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 其它的一些操作函数 (十五)</div></div></a></div><div><a href="/2023/03/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9(%E4%BA%94)/" title="ClickHouse 数据表的增删改(五)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="title">ClickHouse 数据表的增删改(五)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenwen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenlinshan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">码海无涯。。。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ClickHouse-%E4%B9%8B-MergeTree-%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E-%E4%B8%83"><span class="toc-number">1.</span> <span class="toc-text">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MergeTree"><span class="toc-number">1.0.1.</span> <span class="toc-text">MergeTree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE-TTL"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">数据 TTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%BE%84%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">多路径存储策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReplacingMergeTree"><span class="toc-number">1.0.2.</span> <span class="toc-text">ReplacingMergeTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SummingMergeTree"><span class="toc-number">1.0.3.</span> <span class="toc-text">SummingMergeTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AggregatingMergeTree"><span class="toc-number">1.0.4.</span> <span class="toc-text">AggregatingMergeTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CollapsingMergeTree"><span class="toc-number">1.0.5.</span> <span class="toc-text">CollapsingMergeTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VersionedCollapsingMergeTree"><span class="toc-number">1.0.6.</span> <span class="toc-text">VersionedCollapsingMergeTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D-MergeTree-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.7.</span> <span class="toc-text">各种 MergeTree 之间的关系总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">组合关系</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0(%E5%8D%81%E4%B8%80)/" title="ClickHouse 中的常用聚合函数(十一)">ClickHouse 中的常用聚合函数(十一)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)">ClickHouse 中其它常见的表引擎(八)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E%EF%BC%9AMergeTree%20%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E5%85%AD)/" title="ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)">ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/" title="ClickHouse 中的数据查询以及各种子句(九)">ClickHouse 中的数据查询以及各种子句(九)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E5%85%B6%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%20(%E5%8D%81%E4%BA%94)/" title="ClickHouse 其它的一些操作函数 (十五)">ClickHouse 其它的一些操作函数 (十五)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wenwen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>