<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>ClickHouse 中的数据查询以及各种子句(九) | 热心市民温温</title><meta name="author" content="wenwen"><meta name="copyright" content="wenwen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ClickHouse 中的数据查询以及各种子句(九)​																	本文来源： ( https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;tag&#x2F;ClickHouse：一款速度快到让人发指的列式存储数据库&#x2F; )   楔子作为一款 OLAP 型的数据库，它的查询功能可谓是重中之重，而且我相信大家在绝大部分时间都在使用它的查询功能，事实上，在日常运转的过程中，数据">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse 中的数据查询以及各种子句(九)">
<meta property="og:url" content="https://hesay.cn/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/index.html">
<meta property="og:site_name" content="热心市民温温">
<meta property="og:description" content="ClickHouse 中的数据查询以及各种子句(九)​																	本文来源： ( https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;tag&#x2F;ClickHouse：一款速度快到让人发指的列式存储数据库&#x2F; )   楔子作为一款 OLAP 型的数据库，它的查询功能可谓是重中之重，而且我相信大家在绝大部分时间都在使用它的查询功能，事实上，在日常运转的过程中，数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hesay.cn/img/favicon.png">
<meta property="article:published_time" content="2023-04-11T09:04:31.000Z">
<meta property="article:modified_time" content="2023-04-13T09:06:57.974Z">
<meta property="article:author" content="wenwen">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hesay.cn/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hesay.cn/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ClickHouse 中的数据查询以及各种子句(九)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-13 17:06:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="热心市民温温"><span class="site-name">热心市民温温</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">ClickHouse 中的数据查询以及各种子句(九)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-13T09:06:57.974Z" title="更新于 2023-04-13 17:06:57">2023-04-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ClickHouse/">ClickHouse</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ClickHouse 中的数据查询以及各种子句(九)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="ClickHouse-中的数据查询以及各种子句-九"><a href="#ClickHouse-中的数据查询以及各种子句-九" class="headerlink" title="ClickHouse 中的数据查询以及各种子句(九)"></a>ClickHouse 中的数据查询以及各种子句(九)</h1><p>​																	本文来源： ( <a target="_blank" rel="noopener" href="https://www.cnblogs.com/traditional/tag/ClickHouse%EF%BC%9A%E4%B8%80%E6%AC%BE%E9%80%9F%E5%BA%A6%E5%BF%AB%E5%88%B0%E8%AE%A9%E4%BA%BA%E5%8F%91%E6%8C%87%E7%9A%84%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93/">https://www.cnblogs.com/traditional/tag/ClickHouse：一款速度快到让人发指的列式存储数据库/</a> ) </p>
<hr>
<h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p><strong>作为一款 OLAP 型的数据库，它的查询功能可谓是重中之重，而且我相信大家在绝大部分时间都在使用它的查询功能，事实上，在日常运转的过程中，数据查询也是 ClickHouse 的主要工作之一。ClickHouse 完全使用 SQL 作为查询语言，能够以 SELECT 查询语句的形式从数据库中选取数据，这也是它具备流行潜质的重要原因。虽然 ClickHouse 拥有优秀的查询性能，但是我们也不能滥用查询，掌握 ClickHouse 所支持的各种查询子句，并选择合理的查询形式是很有必要的。使用不恰当的 SQL 语句进行查询不仅会带来低性能，还可能导致不可预知的系统错误。</strong></p>
<p><strong>虽然在上面的示例中，我们已经见识过一些查询语句的用法，但那些都是为了演示效果简化后的代码，与真正的生产环境中的代码相差较大。例如在绝大部分场景中，都应该避免使用 SELECT * 来查询数据，因为通配符 * 对于采用列式存储的 ClickHouse 而言没有任何好处。假如面对一张拥有数百个列字段的数据表，下面这两条 SELECT 语句的性能可能会相差 100 倍之多：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br><span class="line"><span class="keyword">SELECT</span> col <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p><strong>使用通配符 * 和按列查询相比，性能可能相差 100 倍，另外 ClickHouse 对于 SQL 语句的解析是大小写敏感的，这意味着 SELECT a 和 SELECT A 表示的语义是不相同的，但关键字大小写不敏感，不过还是建议遵循规范使用大写。此外 ClickHouse 的类型也大小写敏感，比如：UInt8 不可以写成 uint8，String 不可以写成 string；还有大部分函数也是大小写敏感，这些函数都是 ClickHouse 独有的，或者说你在其它关系型数据库中见不到的，但是像 min、max、length、sum、count 等等这些在其它关系型库中也能看到的函数，在 ClickHouse 中则是大小写不敏感的。</strong></p>
<p><strong>下面介绍 ClickHouse 的查询语法，ClickHouse 支持的查询子句和我们平常使用的关系型数据库非常类似，但是在此基础上又提供了很多新的功能，我们来看一下。</strong></p>
<blockquote>
<p><strong>虽然 ClickHouse 的查询是重中之重，但毕竟采用的是 SQL 语法，因此像什么如何起别名、比较运算符、条件运算符等等，这些比较基础的内容就不说了。</strong></p>
</blockquote>
<h2 id="WITH-子句"><a href="#WITH-子句" class="headerlink" title="WITH 子句"></a>WITH 子句</h2><p><strong>ClickHouse 支持 CTE（Common Table Expression，公共表表达式），以增强查询语句的表达。例如下面的函数嵌套：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pow(pow(<span class="number">2</span>, <span class="number">2</span>), <span class="number">3</span>); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─pow(pow(2, 2), 3)─┐</span></span><br><span class="line"><span class="comment">│                64 │</span></span><br><span class="line"><span class="comment">└───────────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>在改用 CTE 的形式后，可以极大地提高语句的可读性和可维护性，简化后的语句如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> pow(<span class="number">2</span>, <span class="number">2</span>) <span class="keyword">AS</span> a <span class="keyword">SELECT</span> pow(a, <span class="number">3</span>); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─pow(a, 3)─┐</span></span><br><span class="line"><span class="comment">│        64 │</span></span><br><span class="line"><span class="comment">└───────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>在 ClickHouse 中的 CTE 通过 WITH 子句表示，而语法格式显然很简单，想象一下编程语言中的变量定义，一般都类似于：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var = 表达式</span><br></pre></td></tr></table></figure>

<p><strong>在后续的的代码编写中，可以使用 var 来代替相应的表达式，而在 ClickHouse 中也是同理：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WITH 表达式 AS var</span><br></pre></td></tr></table></figure>

<p><strong>通过 WITH，我们即可在查询中使用 var 来代替表达式，而根据表达式的不同，可以有以下几种用法：</strong></p>
<h4 id="1-表达式为常量"><a href="#1-表达式为常量" class="headerlink" title="1. 表达式为常量"></a>1. 表达式为常量</h4><p><strong>此时相当于为常量起了一个有意义的名字，这些名字能够在后续的查询子句中被直接访问。例如下面示例中的 start，被直接用在紧接着的 WHERE 子句中：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="number">10</span> <span class="keyword">AS</span> <span class="keyword">start</span></span><br><span class="line"><span class="keyword">SELECT</span> number <span class="keyword">FROM</span> system.numbers <span class="comment">-- 这是一张系统表</span></span><br><span class="line"><span class="keyword">WHERE</span> number <span class="operator">&gt;</span> <span class="keyword">start</span> LIMIT <span class="number">5</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─number─┐</span></span><br><span class="line"><span class="comment">│     11 │</span></span><br><span class="line"><span class="comment">│     12 │</span></span><br><span class="line"><span class="comment">│     13 │</span></span><br><span class="line"><span class="comment">│     14 │</span></span><br><span class="line"><span class="comment">│     15 │</span></span><br><span class="line"><span class="comment">└────────┘</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>如果没有 WITH 子句，那么直接把 start 换成 10 即可，只不过通过 WITH 我们给 10 这个常量起了一个有意义的名字。当然常量不仅是整数，字符串、浮点数、甚至数组都是可以的。</strong></p>
<h4 id="2-表达式为函数调用"><a href="#2-表达式为函数调用" class="headerlink" title="2. 表达式为函数调用"></a>2. 表达式为函数调用</h4><p><strong>感觉此时就类似于替换，例如在下面的示例中，对 data_uncompressed_bytes 使用聚合函数求和后，又紧接着在 SELECT 子句中对其进行了格式化处理。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="built_in">SUM</span>(data_uncompressed_bytes) <span class="keyword">AS</span> bytes</span><br><span class="line"><span class="keyword">SELECT</span> database, formatReadableSize(bytes) <span class="keyword">AS</span> format</span><br><span class="line"><span class="keyword">FROM</span> system.columns</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> database</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> bytes <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─database─┬─format───┐</span></span><br><span class="line"><span class="comment">│ system   │ 5.32 GiB │</span></span><br><span class="line"><span class="comment">│ default  │ 0.00 B   │</span></span><br><span class="line"><span class="comment">└──────────┴──────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>如果不使用 WITH 子句，那么 SELECT 里面出现的就是 formatReadableSize(SUM(data_uncompressed_bytes))，这样读起来不是很方便，所以使用 WITH 子句将里面的聚合函数调用起一个名字叫 bytes，那么后面的查询直接使用 bytes 即可。</strong></p>
<h4 id="3-表达式为子查询"><a href="#3-表达式为子查询" class="headerlink" title="3. 表达式为子查询"></a>3. 表达式为子查询</h4><p><strong>表达式也可以是一个子查询，例如在下面的示例中，借助子查询可以得出各 database 未压缩数据大小与数据总和大小的比例的排名：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SELECT sum(data_uncompressed_bytes) FROM system.columns 会得到一个数值</span></span><br><span class="line"><span class="comment">-- 因此本质上和表达式为常量是类似的，只不过多了一个计算的过程</span></span><br><span class="line"><span class="keyword">WITH</span> (<span class="keyword">SELECT</span> <span class="built_in">sum</span>(data_uncompressed_bytes) <span class="keyword">FROM</span> system.columns) <span class="keyword">AS</span> total_bytes</span><br><span class="line"><span class="keyword">SELECT</span> database, </span><br><span class="line">       (<span class="built_in">sum</span>(data_uncompressed_bytes) <span class="operator">/</span> total_bytes) <span class="operator">*</span> <span class="number">100</span> <span class="keyword">AS</span> database_disk_usage</span><br><span class="line"><span class="keyword">FROM</span> system.columns</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> database</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> database_disk_usage <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─database─┬─database_disk_usage─┐</span></span><br><span class="line"><span class="comment">│ system   │                 100 │</span></span><br><span class="line"><span class="comment">│ default  │                   0 │</span></span><br><span class="line"><span class="comment">└──────────┴─────────────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 WITH 子句时有一点需要特别注意，表达式只能返回的数据不能超过 1 行，否则会抛出异常。我们举个栗子：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155856488-1272004322.png" alt="img"></p>
<p><strong>这里的 WITH AS 就类似于编程语言中的变量赋值，但你不可能让一个变量指代多个值，如果想这么做，那么就将这些值放在一个容器（列表、集合、字典等等）里面。同理，如果 WITH 的表达式返回了多行数据，那么可以将其变成一个数组：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里见到了一个函数 groupArray，我们可以把它当成是普通的聚合函数来理解</span></span><br><span class="line"><span class="comment">-- 类似于 sum，sum 是对同一组的元素进行求和，groupArray 是将同一组的元素组合成数组</span></span><br><span class="line"><span class="keyword">WITH</span> (<span class="keyword">SELECT</span> groupArray(number) <span class="keyword">FROM</span> numbers(<span class="number">10</span>)) <span class="keyword">AS</span> arr <span class="keyword">SELECT</span> arr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─arr───────────────────┐</span></span><br><span class="line"><span class="comment">│ [0,1,2,3,4,5,6,7,8,9] │</span></span><br><span class="line"><span class="comment">└───────────────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>显然此时就没问题了，并且相比关系型数据库，ClickHouse 在行列转换的时候尤为方便。</strong></p>
<h4 id="4-在子查询中重复使用WITH"><a href="#4-在子查询中重复使用WITH" class="headerlink" title="4. 在子查询中重复使用WITH"></a>4. 在子查询中重复使用WITH</h4><p><strong>在子查询中可以嵌套使用 WITH 子句，例如在下面的示例中，在计算出各 database 未压缩数据大小与数据总和的比例之后，又进行了取整函数的调用：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> round(database_disk_usage) <span class="keyword">AS</span> database_disk_usage_v1</span><br><span class="line"><span class="keyword">SELECT</span> database, database_disk_usage, database_disk_usage_v1</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="comment">-- 嵌套</span></span><br><span class="line">    <span class="keyword">WITH</span> (<span class="keyword">SELECT</span> <span class="built_in">sum</span>(data_uncompressed_bytes) <span class="keyword">FROM</span> system.columns) <span class="keyword">AS</span> total_bytes</span><br><span class="line">    <span class="keyword">SELECT</span> database, (<span class="built_in">sum</span>(data_uncompressed_bytes) <span class="operator">/</span> total_bytes) <span class="operator">*</span> <span class="number">100</span> <span class="keyword">AS</span> database_disk_usage</span><br><span class="line">    <span class="keyword">FROM</span> system.columns <span class="keyword">GROUP</span> <span class="keyword">BY</span> database <span class="keyword">ORDER</span> <span class="keyword">BY</span> database_disk_usage <span class="keyword">DESC</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>虽然看起来有点复杂，但是不难理解，不考虑 WITH 的话，那么就是一个嵌套子查询：SELECT … FROM (SELECT … FROM)，只不过两个 SELECT 里面的 database_disk_usage_v1、total_bytes 是用 WITH 声明的变量。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155847398-1492024351.png" alt="img"></p>
<p><strong>而且我们看到如果子查询是作为一张表使用的，那么在关系型数据库中应该起一个别名，但在 ClickHouse 可以不用。</strong></p>
<p><strong>总的来说，WITH 子句就相当于起一个别名，如果你看某个表达式长得不顺眼，那么就可以使用 WITH 将它替换掉，就这么简单。而且一个 WITH 子句是可以为多个表达式起别名的，举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="number">1</span> <span class="keyword">AS</span> a, <span class="number">2</span> <span class="keyword">AS</span> b <span class="keyword">SELECT</span> a <span class="operator">+</span> b; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─plus(a, b)─┐</span></span><br><span class="line"><span class="comment">│          3 │</span></span><br><span class="line"><span class="comment">└────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="其它关系型数据库的-WITH-子句"><a href="#其它关系型数据库的-WITH-子句" class="headerlink" title="其它关系型数据库的 WITH 子句"></a>其它关系型数据库的 WITH 子句</h4><p><strong>ClickHouse 的 WITH 语句和其它的关系型数据库还是有很大差别的，比如 PostgreSQL。如果 PostgreSQL 的话，那么 AS 之后的结果是会被当成是一张表，举个例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设存在一张表叫 girls, 如果是 PostgreSQL 的话</span></span><br><span class="line"><span class="keyword">WITH</span> tmp <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> girls <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">100</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tmp <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- 这么做的话, 在 PostgreSQL 中是完全正确的做法，此时的 tmp 就是 table 中 id 小于 100 的记录组成的结果集</span></span><br><span class="line"><span class="comment">-- 并且它可以作为一张临时表来使用</span></span><br><span class="line"><span class="comment">-- 我们这个示例比较简单, 但是当子查询比较复杂的时候, 通过将子查询当做一张临时表, 可以使查询逻辑更加清晰</span></span><br><span class="line"><span class="comment">-- 并且查询结束之后, 这张临时表也就不存在了</span></span><br><span class="line"><span class="comment">-- 上面这段代码和下面都是等价的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> girls <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> girls <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">100</span>) tmp <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><strong>所以 ClickHouse 的 WITH 中的表达式必须只能有一行，它就等价于为某个复杂的表达式起一个别名，不可以放在 FROM 后面作为临时表来使用。而 PostgreSQL 的 WITH 中的表达式没有任何限制，可以返回任何数据，行数不限，并且可以当成临时表放在 FROM 后面。除此之外，ClickHouse 和 PostgreSQL 的 WITH 语句还有一处不同，那就是 ClickHouse 中别名在 AS 后面，而 PostgreSQL 中别名在 AS 前面。</strong></p>
<blockquote>
<p><strong>注意：WITH 中的表达式如果是子查询，那么会提前计算好，在使用别名的时候使用的是已经计算好的结果。</strong></p>
</blockquote>
<p><strong>问题来了，既然行数有限制，那列数有没有限制呢？我们试一下就知道了，首先创建一张 Memory 数据表，内容如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> women</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─name─────┬─age─┐</span></span><br><span class="line"><span class="comment">│  1 │ 古明地觉  │  17 │</span></span><br><span class="line"><span class="comment">│  2 │ 芙兰朵露  │ 144 │</span></span><br><span class="line"><span class="comment">│  3 │ 琪露诺    │  58 │</span></span><br><span class="line"><span class="comment">└────┴──────────┴─────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们来进行查询：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155837104-1321089989.png" alt="img"></p>
<p><strong>同理通过 WITH，我们还可以实现为字段起别名的效果，举个栗子：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155830593-127511004.png" alt="img"></p>
<p><strong>不过这种做法显然没有太大意义，除非字段名太长了，想起一个短点儿的。</strong></p>
<p><strong>以上就是 WITH 子句，非常简单，核心就一句话：给表达式起别名，后续使用别名来对表达式进行替换。</strong></p>
<h2 id="FROM-子句"><a href="#FROM-子句" class="headerlink" title="FROM 子句"></a>FROM 子句</h2><p><strong>FROM 子句表示从何处读取数据，目前支持如下 3 种形式。</strong></p>
<p><strong>1. 从数据表中取数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> people</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 从子查询中取数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> max_id <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">max</span>(id) <span class="keyword">AS</span> max_id <span class="keyword">FROM</span> people)</span><br><span class="line"><span class="comment">-- 在其它关系型数据库中, 如果子查询作为一张表来使用, 那么必须要起一个别名</span></span><br><span class="line"><span class="comment">-- 但是在 ClickHouse 中不需要, 个人觉得这是个不错的决定，因为起别名我们又不用</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 从表函数中取数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> number <span class="keyword">FROM</span> numbers(N) <span class="comment">-- 会返回 0 到 N - 1 </span></span><br></pre></td></tr></table></figure>

<p><strong>另外 FROM 关键字可以省略，我们在介绍 WITH 子句的时候多次省略 FROM，因为 SELECT 后面是标量，此时会从虚拟表中取值。在 ClickHouse 中，并没有数据库中常见的 DUAL 虚拟表，取而代之的是 system.one。举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 等价于 SELECT 1, 2, 3 FROM system.one，</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─1─┬─2─┬─3─┐</span></span><br><span class="line"><span class="comment">│ 1 │ 2 │ 3 │</span></span><br><span class="line"><span class="comment">└───┴───┴───┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">+</span> <span class="number">2</span>, <span class="number">2</span> <span class="operator">*</span> <span class="number">3</span>;  <span class="comment">-- 此时可以当成计算器来使用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─plus(1, 2)─┬─multiply(2, 3)─┐</span></span><br><span class="line"><span class="comment">│          3 │              6 │</span></span><br><span class="line"><span class="comment">└────────────┴────────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;KOMEIJI SATORI&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─[1, 2, 3]─┬─&#x27;KOMEIJI SATORI&#x27;─┐</span></span><br><span class="line"><span class="comment">│ [1,2,3]   │ KOMEIJI SATORI   │</span></span><br><span class="line"><span class="comment">└───────────┴──────────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ARRAY-JOIN-子句"><a href="#ARRAY-JOIN-子句" class="headerlink" title="ARRAY JOIN 子句"></a>ARRAY JOIN 子句</h2><p><strong>ARRAY JOIN 子句允许在数据表的内部，与数组或嵌套类型的字段进行 JOIN 操作，从而将一行数组展开为多行。接下来让我们看看它的基础用法，首先新建一张包含 Array 数组字段的测试表：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    title String,</span><br><span class="line">    <span class="keyword">value</span> <span class="keyword">Array</span>(UInt8)</span><br><span class="line">) ENGINE <span class="operator">=</span> Memory();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 然后写入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span> (<span class="string">&#x27;food&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), (<span class="string">&#x27;fruit&#x27;</span>, [<span class="number">3</span>, <span class="number">4</span>]), (<span class="string">&#x27;meat&#x27;</span>, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─value───┐</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3] │</span></span><br><span class="line"><span class="comment">│ fruit │ [3,4]   │</span></span><br><span class="line"><span class="comment">│ meat  │ []      │</span></span><br><span class="line"><span class="comment">└───────┴─────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>在一条 SELECT 语句中，只能存在一个 ARRAY JOIN（使用子查询除外），目前支持 INNER 和 LEFT 两种 JOIN 策略：</strong></p>
<h4 id="INNER-ARRAY-JOIN"><a href="#INNER-ARRAY-JOIN" class="headerlink" title="INNER ARRAY JOIN"></a>INNER ARRAY JOIN</h4><p><strong>ARRAY JOIN 在默认情况下使用的是 INNER JOIN 策略，例如下面的语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">value</span> <span class="keyword">FROM</span> t1 <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> <span class="keyword">value</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─value─┐</span></span><br><span class="line"><span class="comment">│ food  │     1 │</span></span><br><span class="line"><span class="comment">│ food  │     2 │</span></span><br><span class="line"><span class="comment">│ food  │     3 │</span></span><br><span class="line"><span class="comment">│ fruit │     3 │</span></span><br><span class="line"><span class="comment">│ fruit │     4 │</span></span><br><span class="line"><span class="comment">└───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>从查询结果可以发现，最终的数据基于 value 数组被展开成了多行，并且排除掉了空数组，同时会自动和其它字段进行组合（相当于按行合并）。在使用 ARRAY JOIN 时，如果还想访问展开前的数组字段，那么只需为原有的数组字段添加一个别名即可，例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果不给 ARRAY JOIN 后面的 value 起一个别名，那么 value 就是展开后的结果</span></span><br><span class="line"><span class="comment">-- 如果给 ARRAY JOIN 后面的 value 起一个别名 val，那么 value 就还是展开前的数组字段</span></span><br><span class="line"><span class="comment">-- 而 val 才是展开后的结果，所以再反过来，让 val 出现在 SELECT 中即可</span></span><br><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">value</span>, val <span class="keyword">FROM</span> t1 <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> <span class="keyword">value</span> <span class="keyword">AS</span> val;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─value───┬─val─┐</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3] │   1 │</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3] │   2 │</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3] │   3 │</span></span><br><span class="line"><span class="comment">│ fruit │ [3,4]   │   3 │</span></span><br><span class="line"><span class="comment">│ fruit │ [3,4]   │   4 │</span></span><br><span class="line"><span class="comment">└───────┴─────────┴─────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到 ClickHouse 的确是当之无愧的最强 OLAP 数据库，不单单是速度快，最重要的是，它提供的查询语法也很方便。如果你用过 Hive 的话，会发现这里特别像里面的 lateral view explode 语法。</strong></p>
<h4 id="LEFT-ARRAY-JOIN"><a href="#LEFT-ARRAY-JOIN" class="headerlink" title="LEFT ARRAY JOIN"></a>LEFT ARRAY JOIN</h4><p><strong>ARRAY JOIN 子句支持 LEFT 连接策略，例如执行下面的语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">value</span>, val <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> <span class="keyword">value</span> <span class="keyword">AS</span> val;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─value───┬─val─┐</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3] │   1 │</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3] │   2 │</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3] │   3 │</span></span><br><span class="line"><span class="comment">│ fruit │ [3,4]   │   3 │</span></span><br><span class="line"><span class="comment">│ fruit │ [3,4]   │   4 │</span></span><br><span class="line"><span class="comment">│ meat  │ []      │   0 │</span></span><br><span class="line"><span class="comment">└───────┴─────────┴─────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>在改为 LEFT 连接查询后，可以发现，在 INNER JOIN 中被排除掉的空数组出现在了返回的结果集中。但此时的 val 是零值，所以 LEFT ARRAY JOIN 个人觉得不是很常用，一般都是用 ARRAY JOIN。</strong></p>
<h4 id="关于数组的一些骚操作"><a href="#关于数组的一些骚操作" class="headerlink" title="关于数组的一些骚操作"></a>关于数组的一些骚操作</h4><p><strong>在关系型数据库里面我们一般都不太喜欢用数组，但是在 ClickHouse 中数组会用的非常多，并且操作起来非常简单。ClickHouse 里面提供了非常多的函数，用好了的话，就相当于分布式的 pandas。下面就先来看一下关于数组的一些函数，这里先介绍一部分，提前感受一下 ClickHouse 的强大，首先我们创建一张新表，并写入测试数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─────────dt─┬─cash───────┐</span></span><br><span class="line"><span class="comment">│ 2020-01-01 │ [10,10,10] │</span></span><br><span class="line"><span class="comment">│ 2020-01-02 │ [20,20,20] │</span></span><br><span class="line"><span class="comment">│ 2020-01-01 │ [10,10,10] │</span></span><br><span class="line"><span class="comment">│ 2020-01-02 │ [20,20]    │</span></span><br><span class="line"><span class="comment">│ 2020-01-03 │ []         │</span></span><br><span class="line"><span class="comment">│ 2020-01-03 │ [30,30,30] │</span></span><br><span class="line"><span class="comment">└────────────┴────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>groupArray</strong></p>
<p><strong>这个函数已经出现过一次了，我们说它是把多行数据合并成一个数组，相当于是聚合函数的一种。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dt, groupArray(cash) <span class="keyword">FROM</span> t2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> dt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─────────dt─┬─groupArray(cash)────────┐</span></span><br><span class="line"><span class="comment">│ 2020-01-01 │ [[10,10,10],[10,10,10]] │</span></span><br><span class="line"><span class="comment">│ 2020-01-02 │ [[20,20,20],[20,20]]    │</span></span><br><span class="line"><span class="comment">│ 2020-01-03 │ [[],[30,30,30]]         │</span></span><br><span class="line"><span class="comment">└────────────┴─────────────────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到 groupArray 就等同于类似 count、sum 这样的聚合函数，将同一组的数据组合成一个新的数组。由于本来的元素就是数组，所以这里就是数组嵌套数组。</strong></p>
<p><strong>除了 groupArray 之外，还有一个 groupUniqArray，在组合的时候会对元素进行去重：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dt, groupUniqArray(cash) <span class="keyword">FROM</span> t2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> dt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─────────dt─┬─groupUniqArray(cash)─┐</span></span><br><span class="line"><span class="comment">│ 2020-01-01 │ [[10,10,10]]         │</span></span><br><span class="line"><span class="comment">│ 2020-01-02 │ [[20,20],[20,20,20]] │</span></span><br><span class="line"><span class="comment">│ 2020-01-03 │ [[],[30,30,30]]      │</span></span><br><span class="line"><span class="comment">└────────────┴──────────────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到 ‘2020-01-01’ 这行数据被去重了。</strong></p>
<p><strong>arrayFlatten</strong></p>
<p><strong>从名字上应该能猜出来，直接看例子就明白了。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dt, </span><br><span class="line">       groupArray(cash),</span><br><span class="line">       arrayFlatten(groupArray(cash)) <span class="keyword">FROM</span> t2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> dt;</span><br></pre></td></tr></table></figure>

<p><strong>我们在 groupArray(cash) 基础上又调用了 arrayFlatten：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155811386-223388004.png" alt="img"></p>
<p><strong>相信该函数的作用显而易见的，就是将多个嵌套数组扁平化，另外这里的查询语句还可以美化一下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 WITH 子句，提前将 groupArray(cash) 起一个别名</span></span><br><span class="line"><span class="keyword">WITH</span> groupArray(cash) <span class="keyword">AS</span> group_cash</span><br><span class="line"><span class="keyword">SELECT</span> dt, </span><br><span class="line">       group_cash,</span><br><span class="line">       arrayFlatten(group_cash) <span class="keyword">FROM</span> t2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> dt;</span><br><span class="line">       </span><br><span class="line"><span class="comment">-- 或者这么做</span></span><br><span class="line"><span class="keyword">SELECT</span> dt,</span><br><span class="line">       groupArray(cash) <span class="keyword">AS</span> group_cash,</span><br><span class="line">       arrayFlatten(group_cash) <span class="keyword">FROM</span> t2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> dt;</span><br><span class="line"><span class="comment">-- 我们看到即使是在 SELECT 里面起的别名也是可以被使用的</span></span><br><span class="line"><span class="comment">-- 另外顺序也没有限制，比如下面的做法也是合法的</span></span><br><span class="line"><span class="keyword">SELECT</span> dt, </span><br><span class="line">       arrayFlatten(group_cash), </span><br><span class="line">       groupArray(cash) <span class="keyword">AS</span> group_cash <span class="keyword">FROM</span> t2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> dt;</span><br></pre></td></tr></table></figure>

<p><strong>splitByChar</strong></p>
<p><strong>将字符串按照指定字符分割成数组：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> splitByChar(<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;komeiji^koishi&#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─splitByChar(&#x27;^&#x27;, &#x27;komeiji^koishi&#x27;)─┐</span></span><br><span class="line"><span class="comment">│ [&#x27;komeiji&#x27;,&#x27;koishi&#x27;]               │</span></span><br><span class="line"><span class="comment">└────────────────────────────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>arrayJoin</strong></p>
<p><strong>该函数和 ARRAY JOIN 子句的作用非常类似：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155803358-2134270761.png" alt="img"></p>
<p><strong>arrayMap</strong></p>
<p><strong>对数组中的每一个元素都以相同的规则进行映射：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- arrayMap(x -&gt; x * 2, value) 表示将 value 中的每一个元素都乘以 2，然后返回一个新数组</span></span><br><span class="line"><span class="comment">-- 而 mapV 就是变换过后的新数组，直接拿来用即可</span></span><br><span class="line"><span class="keyword">SELECT</span> title, arrayMap(x <span class="operator">-</span><span class="operator">&gt;</span> x <span class="operator">*</span> <span class="number">2</span>, <span class="keyword">value</span>) <span class="keyword">AS</span> mapV, v</span><br><span class="line"><span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> mapV <span class="keyword">as</span> v</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─mapV────┬─v─┐</span></span><br><span class="line"><span class="comment">│ food  │ [2,4,6] │ 2 │</span></span><br><span class="line"><span class="comment">│ food  │ [2,4,6] │ 4 │</span></span><br><span class="line"><span class="comment">│ food  │ [2,4,6] │ 6 │</span></span><br><span class="line"><span class="comment">│ fruit │ [6,8]   │ 6 │</span></span><br><span class="line"><span class="comment">│ fruit │ [6,8]   │ 8 │</span></span><br><span class="line"><span class="comment">│ meat  │ []      │ 0 │</span></span><br><span class="line"><span class="comment">└───────┴─────────┴───┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 另外展开的字段也可以不止一个</span></span><br><span class="line"><span class="keyword">SELECT</span> title, </span><br><span class="line">       arrayMap(x <span class="operator">-</span><span class="operator">&gt;</span> x <span class="operator">*</span> <span class="number">2</span>, <span class="keyword">value</span>) <span class="keyword">AS</span> mapV, v,</span><br><span class="line">       <span class="keyword">value</span>, v_1</span><br><span class="line"><span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> mapV <span class="keyword">as</span> v, <span class="keyword">value</span> <span class="keyword">AS</span> v_1</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─mapV────┬─v─┬─value───┬─v_1─┐</span></span><br><span class="line"><span class="comment">│ food  │ [2,4,6] │ 2 │ [1,2,3] │   1 │</span></span><br><span class="line"><span class="comment">│ food  │ [2,4,6] │ 4 │ [1,2,3] │   2 │</span></span><br><span class="line"><span class="comment">│ food  │ [2,4,6] │ 6 │ [1,2,3] │   3 │</span></span><br><span class="line"><span class="comment">│ fruit │ [6,8]   │ 6 │ [3,4]   │   3 │</span></span><br><span class="line"><span class="comment">│ fruit │ [6,8]   │ 8 │ [3,4]   │   4 │</span></span><br><span class="line"><span class="comment">│ meat  │ []      │ 0 │ []      │   0 │</span></span><br><span class="line"><span class="comment">└───────┴─────────┴───┴─────────┴─────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h4><p><strong>在前面介绍数据定义时曾介绍过，嵌套数据类型的本质是数组，所以 ARRAY JOIN 也支持嵌套数据类型。接下来继续用一组示例说明，首先新建一张包含嵌套类型的测试表：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3(</span><br><span class="line">    title String,</span><br><span class="line">    nested Nested</span><br><span class="line">    (</span><br><span class="line">        v1 UInt32,</span><br><span class="line">        v2 UInt64</span><br><span class="line">    )</span><br><span class="line">) ENGINE <span class="operator">=</span> <span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 接着写入测试数据</span></span><br><span class="line"><span class="comment">-- 在写入嵌套数据类型时，记得同一行数据中各个数组的长度需要对齐，而对多行数据之间的数组长度没有限制</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t3</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;food&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]),</span><br><span class="line">       (<span class="string">&#x27;fruit&#x27;</span>, [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">40</span>, <span class="number">50</span>]),</span><br><span class="line">       (<span class="string">&#x27;meat&#x27;</span>, [], [])</span><br></pre></td></tr></table></figure>

<p><strong>对嵌套类型数据的访问，ARRAY JOIN 既可以直接使用字段列名：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155751689-560561486.png" alt="img"></p>
<p><strong>也可以使用点访问符的形式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- nested 只有 v1 和 v2</span></span><br><span class="line"><span class="comment">-- 所以 ARRAY JOIN nested.v1, nested.v2 等价于 ARRAY JOIN nested</span></span><br><span class="line"><span class="keyword">SELECT</span> title, nested.v1, nested.v2 <span class="keyword">FROM</span> t3 <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> nested.v1, nested.v2</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─nested.v1─┬─nested.v2─┐</span></span><br><span class="line"><span class="comment">│ food  │         1 │        10 │</span></span><br><span class="line"><span class="comment">│ food  │         2 │        20 │</span></span><br><span class="line"><span class="comment">│ food  │         3 │        30 │</span></span><br><span class="line"><span class="comment">│ fruit │         4 │        40 │</span></span><br><span class="line"><span class="comment">│ fruit │         5 │        50 │</span></span><br><span class="line"><span class="comment">└───────┴───────────┴───────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>嵌套类型也支持 ARRAY JOIN 部分嵌套字段：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, nested.v1, nested.v2 <span class="keyword">FROM</span> t3 <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> nested.v1</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─nested.v1─┬─nested.v2──┐</span></span><br><span class="line"><span class="comment">│ food  │         1 │ [10,20,30] │</span></span><br><span class="line"><span class="comment">│ food  │         2 │ [10,20,30] │</span></span><br><span class="line"><span class="comment">│ food  │         3 │ [10,20,30] │</span></span><br><span class="line"><span class="comment">│ fruit │         4 │ [40,50]    │</span></span><br><span class="line"><span class="comment">│ fruit │         5 │ [40,50]    │</span></span><br><span class="line"><span class="comment">└───────┴───────────┴────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到，在这种情形下，只有被 ARRAY JOIN 的数组才会展开。</strong></p>
<p><strong>在查询嵌套类型时也能够通过别名的形式访问原始数组：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, </span><br><span class="line">       nested.v1, nested.v2, </span><br><span class="line">       n.v1, n.v2  </span><br><span class="line"><span class="keyword">from</span> t3 <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> nested <span class="keyword">AS</span> n;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─nested.v1─┬─nested.v2──┬─n.v1─┬─n.v2─┐</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3]   │ [10,20,30] │    1 │   10 │</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3]   │ [10,20,30] │    2 │   20 │</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3]   │ [10,20,30] │    3 │   30 │</span></span><br><span class="line"><span class="comment">│ fruit │ [4,5]     │ [40,50]    │    4 │   40 │</span></span><br><span class="line"><span class="comment">│ fruit │ [4,5]     │ [40,50]    │    5 │   50 │</span></span><br><span class="line"><span class="comment">└───────┴───────────┴────────────┴──────┴──────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 所以 ARRAY JOIN nested 后面如果没有 AS，那么这个 nested.v1 和 nest.v2 就是展开后的值</span></span><br><span class="line"><span class="comment">-- 如果 ARRAY JOIN nested AS n，起了一个别名，那么 nested.v1 和 nest.v2 就是展开前值，也就是数组本身</span></span><br><span class="line"><span class="comment">-- 而 n.v1 和 n.v2 才是展开后的值</span></span><br><span class="line"><span class="comment">-- 另外 ARRAY JOIN nested AS n，这个 n 可以不使用</span></span><br><span class="line"><span class="keyword">SELECT</span> title, </span><br><span class="line">       nested.v1, nested.v2</span><br><span class="line"><span class="keyword">from</span> t3 <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> nested <span class="keyword">AS</span> n;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─title─┬─nested.v1─┬─nested.v2──┐</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3]   │ [10,20,30] │</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3]   │ [10,20,30] │</span></span><br><span class="line"><span class="comment">│ food  │ [1,2,3]   │ [10,20,30] │</span></span><br><span class="line"><span class="comment">│ fruit │ [4,5]     │ [40,50]    │</span></span><br><span class="line"><span class="comment">│ fruit │ [4,5]     │ [40,50]    │</span></span><br><span class="line"><span class="comment">└───────┴───────────┴────────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="JOIN-子句"><a href="#JOIN-子句" class="headerlink" title="JOIN 子句"></a>JOIN 子句</h2><p><strong>JOIN 子句可以对左右两张表的数据进行连接，这是最常用的查询子句之一，它的语法包含连接精度和连接类型两部分。目前 ClickHouse 支持的 JOIN 子句形式如图所示：</strong></p>
<p><strong>由上图可知，连接精度分为 ALL、ANY 和 ASOF 三种（准确的说是五种，还有 SEMI 和 ANTI，这两个过会再提），而连接类型也可分为外连接、内连接和交叉连接三种。</strong></p>
<p><strong>除此之外，JOIN 查询还可以根据其执行策略被划分为本地查询和远程查询。关于远程查询的内容放在后续章节进行说明，这里着重讲解本地查询。</strong></p>
<h4 id="连接精度"><a href="#连接精度" class="headerlink" title="连接精度"></a>连接精度</h4><p><strong>连接精度决定了 JOIN 查询在连接数据时所使用的策略，目前支持 ALL、ANY 和 ASOF 三种类型。如果不主动声明，则默认是 ALL。可以通过 join_default_strictness 配置参数修改默认的连接精度类型。</strong></p>
<p><strong>那么这个连接精度指的是啥呢？举个栗子就明白了。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─count─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │    30 │</span></span><br><span class="line"><span class="comment">│  2 │ A002  │    28 │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │    32 │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code2─┬─count─┐</span></span><br><span class="line"><span class="comment">│  1 │ B001  │    35 │</span></span><br><span class="line"><span class="comment">│  1 │ B001  │    29 │</span></span><br><span class="line"><span class="comment">│  3 │ B003  │    31 │</span></span><br><span class="line"><span class="comment">│  4 │ B004  │    38 │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>以上是用于测试的表数据，下面进行测试：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2 </span><br><span class="line"><span class="keyword">FROM</span> tbl_1 <span class="keyword">AS</span> t1 </span><br><span class="line"><span class="keyword">ALL</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl_2 <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │ B003  │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 一切正常，跟一般的关系型数据库是类似的，但如果将 ALL 改成 ANY</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2 </span><br><span class="line"><span class="keyword">FROM</span> tbl_1 <span class="keyword">AS</span> t1 </span><br><span class="line"><span class="keyword">ANY</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl_2 <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │ B003  │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>所以结论很清晰了，如果左表内的一行数据，在右表中有多行数据与之连接匹配，那么当连接精度为 ALL，会返回右表中全部连接的数据；当连接精度为 ANY，会仅返回右表中第一行连接的数据</strong></p>
<p><strong>这就是连接精度，没什么好稀奇的，不过在关系型数据库中则没有连接精度的概念，因为当出现这种情况，只有一个策略，那就是直接返回右表中匹配的全部数据。而在 ClickHouse 中，给了我们自由选择的权利。</strong></p>
<p><strong>除了 ALL 和 ANY 之外还有一个 ASOF，它是做什么的呢？首先无论 ALL 还是 ANY，在连接的时候必须是等值连接。比如上面的 t1.id &#x3D; t2.id，如果改成 t1.id &gt;&#x3D; t2.id 就是错误的，如果是多个连接条件，那么这些连接条件都必须是等值连接。但 ASOF 表示模糊连接，也就是它允许你在等值连接的后面加上一个非等值连接，举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2, t1.count <span class="keyword">AS</span> count1, t2.count <span class="keyword">AS</span> count2</span><br><span class="line"><span class="keyword">FROM</span> tbl_1 <span class="keyword">AS</span> t1 </span><br><span class="line"><span class="keyword">ALL</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl_2 <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┬─count1─┬─count2─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │     30 │     35 │</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │     30 │     29 │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │ B003  │     32 │     31 │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┴────────┴────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2, t1.count <span class="keyword">AS</span> count1, t2.count <span class="keyword">AS</span> count2</span><br><span class="line"><span class="keyword">FROM</span> tbl_1 <span class="keyword">AS</span> t1 </span><br><span class="line">ASOF <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl_2 <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id <span class="keyword">AND</span> t1.count <span class="operator">&gt;</span> t2.count;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┬─count1─┬─count2─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │     30 │     29 │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │ B003  │     32 │     31 │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┴────────┴────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2, t1.count <span class="keyword">AS</span> count1, t2.count <span class="keyword">AS</span> count2</span><br><span class="line"><span class="keyword">FROM</span> tbl_1 <span class="keyword">AS</span> t1 </span><br><span class="line">ASOF <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl_2 <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id <span class="keyword">AND</span> t1.count <span class="operator">&lt;</span> t2.count;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┬─count1─┬─count2─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │     30 │     35 │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┴────────┴────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>所以结论很清晰，如果连接精度为 ALL 或者 ANY，那么所有的连接条件必须为等值连接，如果出现了非等值连接则报错。而这两者的唯一区别就在于：</strong></p>
<ul>
<li><code>ALL：如果右表有多条数据匹配，返回所有的匹配的数据</code></li>
<li><code>ANY：如果右表有多条数据匹配，返回第一条匹配的数据</code></li>
</ul>
<p><strong>如果连接精度为 ASOF，那么允许在等值连接条件后面追加一个非等值连接，所以上面的 t1.id &#x3D; t2.id 是等值连接，t1.count &gt; t2.count 是非等值连接。但需要注意的是：使用非等值连接时，这个非等值可以是 &gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;，但不能是 !&#x3D;；并且对于 ASOF 而言，连接条件必须是等值连接和非等值连接的组合，两者缺一不可。</strong></p>
<blockquote>
<p><strong>对于 ASOF 而言，如果右表中有多行数据匹配，只会返回第一行。</strong></p>
</blockquote>
<h4 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h4><p><strong>连接类型就比较简单了，这个和关系型数据库是完全类似的。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 省略连接精度，默认为 ALL</span></span><br><span class="line"><span class="comment">-- 左连接</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2 </span><br><span class="line"><span class="keyword">FROM</span> tbl_1 t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tbl_2 t2 </span><br><span class="line"><span class="keyword">USING</span>(id); <span class="comment">-- 等价于 t1.id = t2.id</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  2 │ A002  │       │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │ B003  │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右连接</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2 </span><br><span class="line"><span class="keyword">FROM</span> tbl_1 t1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> tbl_2 t2 </span><br><span class="line"><span class="keyword">USING</span>(id);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │ B003  │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┐</span></span><br><span class="line"><span class="comment">│  4 │       │ B004  │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全连接</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2 </span><br><span class="line"><span class="keyword">FROM</span> tbl_1 t1 <span class="keyword">FULL</span> <span class="keyword">JOIN</span> tbl_2 t2 </span><br><span class="line"><span class="keyword">USING</span>(id);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  1 │ A001  │ B001  │</span></span><br><span class="line"><span class="comment">│  2 │ A002  │       │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │ B003  │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┐</span></span><br><span class="line"><span class="comment">│  4 │       │ B004  │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>和关系型数据库类似，但有一点区别，就是当没有与之匹配的记录时，会使用对应类型的空值进行补全，而不是 Null。这里没有指定连接精度，默认为 ALL，此外 LEFT &#x2F; RIGHT &#x2F; FULL JOIN 后面都可以加上一个 OUTER，不过也可以不加。最后是交叉连接，交叉连接直接会去笛卡尔积，不需要任何的连接条件。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155733180-1723661310.png" alt="img"></p>
<h4 id="SEMI-和-ANTI"><a href="#SEMI-和-ANTI" class="headerlink" title="SEMI 和 ANTI"></a>SEMI 和 ANTI</h4><p><strong>我们之前说连接精度不止 ALL、ANY、ASOF 三种，还有 SEMI 和 ANTI，只不过这两个比较特殊，因为它们只能用在 LEFT JOIN 和 RIGHT JOIN 上面，所以我们单独介绍。</strong></p>
<ul>
<li><code>t1 SEMI LEFT JOIN t2 USING(id)：遍历 t1 中的 id，如果存在于 t2 中，则输出</code></li>
<li><code>t1 SEMI RIGHT JOIN t2 USING(id)：遍历 t2 中的 id，如果存在于 t1 中，则输出</code></li>
<li><code>t1 ANTI LEFT JOIN t2 USING(id)：遍历 t1 中的 id，如果不存在于 t2 中，则输出</code></li>
<li><code>t1 ANTI RIGHT JOIN t2 USING(id)：遍历 t2 中的 id，如果不存在于 t1 中，则输出</code></li>
</ul>
<p><strong>我们举个栗子：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155724985-600169291.png" alt="img"></p>
<p><strong>ANTI 则与之类似，只不过它的策略是不出现才输出，可以自己尝试一下。另外可能有人发现，这个 SEMI 的功能貌似有些重复了，因为我们使用 ALL 和 ANY 完全可以取代。其实如果你用过 hive 的话，会发现 SEMI LEFT JOIN 和 ANTI LEFT JOIN 是 IN&#x2F;EXISTS 的一种更加高效的实现：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这种子查询应该非常常见了，查询一张表，而过滤的条件该表的某个字段的取值要出现在另一张表的某个字段中</span></span><br><span class="line"><span class="keyword">SELECT</span> id, code1 <span class="keyword">FROM</span> tbl_1 <span class="keyword">WHERE</span> id <span class="keyword">in</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tbl_2);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │</span></span><br><span class="line"><span class="comment">└────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 而通过 SEMI LEFT JOIN 的话，效率会更高一些</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1 <span class="keyword">FROM</span> tbl_1 t1 </span><br><span class="line">SEMI <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tbl_2 t2 <span class="keyword">USING</span>(id)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┐</span></span><br><span class="line"><span class="comment">│  1 │ A001  │</span></span><br><span class="line"><span class="comment">│  3 │ A003  │</span></span><br><span class="line"><span class="comment">└────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ANTI 则是为了 NOT IN/EXISTS </span></span><br></pre></td></tr></table></figure>

<p><strong>两者的输出是一致的，所以 SEMI &#x2F; ANTI LEFT JOIN 是为了 IN&#x2F;EXISTS 这类场景而设计的，至于 SEMI RIGHT JOIN、ANTI RIGHT JOIN 就用的不是很多了。</strong></p>
<p><strong>Hive 里有一个 LEFT SEMI JOIN，单词顺序调换了一下，用途是类似的，不过它的局限性要比 ClickHouse 中的 SEMI LEFT JOIN 大很多。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Hive，这个 t2.xxx 只能出现在 ON 子句中用于连接，不可用在其它地方</span></span><br><span class="line">t1 <span class="keyword">LEFT</span> SEMI <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ClickHouse，t2.xxx 除了可以出现在 ON 子句中，可以出现在 SELECT 子句中，WHERE 子句中</span></span><br><span class="line">t1 SEMI <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举个栗子：</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2 </span><br><span class="line"><span class="keyword">FROM</span> tbl_1 t1 SEMI </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tbl_2 t2 </span><br><span class="line"><span class="keyword">USING</span>(id) <span class="keyword">where</span> t2.code2 <span class="operator">=</span> <span class="string">&#x27;B003&#x27;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─id─┬─code1─┬─code2─┐</span></span><br><span class="line"><span class="comment">│  3 │ A003  │ B003  │</span></span><br><span class="line"><span class="comment">└────┴───────┴───────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>另外 Hive 里面只有 LEFT SEMI JOIN，没有其它的，但 ClickHouse 的选择就多了很多。</strong></p>
<h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p><strong>在进行多张数据表的连接查询时，ClickHouse 会将它们转为两两连接的形式。我们首先再创建一张表：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155714466-1251789186.png" alt="img"></p>
<p><strong>然后对三张测试表进行连接查询：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2, t3.code3</span><br><span class="line"><span class="keyword">FROM</span> tbl_1 <span class="keyword">AS</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl_2 <span class="keyword">AS</span> t2 <span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tbl_3 <span class="keyword">AS</span> t3 <span class="keyword">ON</span> t1.id <span class="operator">=</span> t3.id</span><br></pre></td></tr></table></figure>

<p><strong>在执行上述查询时，tbl_1 和 tbl_2 会先进行内连接，之后再将它们的结果集合 tbl_3 进行左连接。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155706262-2109411026.png" alt="img"></p>
<p><strong>另外 ClickHouse 也支持关联查询的语法，只不过会自动转成指定的连接查询，举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关联查询，如果没有 WHERE，那么三张表会做笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2, t3.code3</span><br><span class="line"><span class="keyword">FROM</span> tbl_1 t1, tbl_2 t2, tbl_3 t3 </span><br><span class="line"><span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.id <span class="keyword">AND</span> t1.id <span class="operator">=</span> t3.id</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─t1.id─┬─t1.code1─┬─t2.code2─┬─t3.code3─┐</span></span><br><span class="line"><span class="comment">│     3 │ A003     │ B003     │ C003     │</span></span><br><span class="line"><span class="comment">└───────┴──────────┴──────────┴──────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>以上就是关联查询，虽然也能实现，不过还是不推荐这种做法，因为此时连接条件和过滤条件都写在了 WHERE 子句里面，看起来会比较混乱。所以更推荐连接查询（ClickHouse 会自动转化），也就是 JOIN ON 的形式，此时 ON 后面写连接条件，而数据过滤条件写 WHERE 里面（当然我们这里不需要过滤）。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.id, t1.code1, t2.code2, t3.code3</span><br><span class="line"><span class="keyword">FROM</span> tbl_1 t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl_2 t2 <span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl_3 t3 <span class="keyword">ON</span> t1.id <span class="operator">=</span> t3.id</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌─t1.id─┬─t1.code1─┬─t2.code2─┬─t3.code3─┐</span></span><br><span class="line"><span class="comment">│     3 │ A003     │ B003     │ C003     │</span></span><br><span class="line"><span class="comment">└───────┴──────────┴──────────┴──────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><strong>最后，还有两个关于 JOIN 查询的注意事项。</strong></p>
<p><strong>1. 关于性能</strong></p>
<p><strong>最后，还有两个关于 JOIN 查询的注意事项。为了能够优化 JOIN 查询性能，首先应该遵循左大右小的原则，即数据量小的表要放在右侧。这是因为在执行 JOIN 查询时，无论使用的是哪种连接方式，右表都会被全部加载到内存中与左表进行比较。</strong></p>
<p><strong>其次，JOIN 查询目前没有缓存的支持，这意味着每一次 JOIN 查询，即便是连续执行相同的 SQL，也都会生成一次全新的执行计划。如果应用程序会大量使用 JOIN 查询，则需要进一步考虑借助上层应用侧的缓存服务或使用 JOIN 表引擎来改善性能。</strong></p>
<p><strong>最后，如果是在大量维度属性补全的查询场景中，则建议使用字典代替 JOIN 查询。因为在进行多表的连接查询时，查询会转换成两两连接的形式，而这种滚雪球式的查询很可能带来性能问题。</strong></p>
<p><strong>2. 空值策略</strong></p>
<p><strong>在之前的介绍中，连接查询的空值（那些未被连接的数据）是由默认值填充的，这与其他数据库所采取的策略不同（由Null 填充）。连接查询的空值策略通过 join_use_nulls 参数指定的，默认为 0。当参数值为 0 时，空值由数据类型的默认值填充；而当参数值为 1 时，空值由 Null 填充。</strong></p>
<h2 id="WHERE-与-PREWHERE-子句"><a href="#WHERE-与-PREWHERE-子句" class="headerlink" title="WHERE 与 PREWHERE 子句"></a>WHERE 与 PREWHERE 子句</h2><p><strong>WHERE 子句基于条件表达式来实现数据过滤，如果过滤条件恰好是主键字段，则能够进一步借助索引过滤数据区间，从而加速查询，所以 WHERE 子句是一条查询语句能否启用索引的判断依据，前提是表引擎支持索引特性。</strong></p>
<p><strong>除了 WHERE，ClickHouse 还支持全新的 PREWHERE 子句，PREWHERE 目前只能用于 MegeTee 系列的表引擎，它可以看作对是 WHERE 的一种优化，其作用与 WHERE 相同，均是用来过滤数据。但它们的不同之处在于。使用 PREWHERE 时，首先只会读取 PREWHERE 指定的列字段数据，用于数据过滤的条件判断。待数据过滤之后再读取 SELECT 声明的列字段以补全其余属性。所以在一些场合下，PREWHERE 相比 WHERE 而言，处理的数据量更少，性能更高。</strong></p>
<p><strong>既然 WHERE 子句性能更优，那么是否需要将所有的 WHERE 子句都替换成 PREWHERE 子句呢？其实大可不必，因为 ClickHouse 实现了自我优化的功能，会在条件合适的情况下将 WHERE 替换为 PREWHERE。如果想开启这项特性，只需要将 optimize_move_to_prewhere 设置为 1 即可，当然默认就为 1，即开启状态。</strong></p>
<p><strong>但凡事也有例外，以下情形不会自动优化：</strong></p>
<p><strong>1）使用了常量表达式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, code <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>2）使用了默认值为 ALIAS 类型的字段：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设 code 的默认值类型是 ALIAS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, code <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> code <span class="operator">=</span> <span class="string">&#x27;A000&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>3）包含了 arrayJoin、globalIn、globalNotIn 或者 indexHint 查询的：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, nested.v1, nested.v2 <span class="keyword">FROM</span> tbl <span class="keyword">ARRAY</span> <span class="keyword">JOIN</span> nested <span class="keyword">WHERE</span> nested.v1 <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>4）SELECT 查询的列字段和 WHERE 谓词相同：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> v3 <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> v3 <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>5）使用了主键字段：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;A000&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>虽然在上述情形中 ClickHouse 不会自动将谓词移动到 PREWHERE，但仍然可以主动使用 PREWHERE。以主键字段为例，当使用 PREWHERE 进行主键查询时，首先会通过稀疏索引过滤数据区间（index_granularity 粒度），接着会读取 PREWHERE 指定的条件列进一步过滤，这样一来就有可能截掉数据区间的尾巴，从而返回低于 index_granularity 粒度的数据范围。但即便如此，相比其他场合移动谓词所带来的性能提升，这类效果还是比较有限的，所以目前 ClickHouse 在这类场合下仍然保持不移动的处理方式。</strong></p>
<h2 id="GROUP-BY-子句"><a href="#GROUP-BY-子句" class="headerlink" title="GROUP BY 子句"></a>GROUP BY 子句</h2><p><strong>GROUP BY 又称聚合查询，是最常用的子句之一，它是让 ClickHouse 最凸显卓越性能的地方。在 GROUP BY 后声明的表达式，通常称为聚合键或者 Key，数据会按照聚合键进行聚合。ClickHouse 的聚合查询中，和关系型数据库也是类似的。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只有聚合函数，可以省略 GROUP BY</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(data_compressed_bytes) <span class="keyword">AS</span> compressed,</span><br><span class="line">       <span class="built_in">sum</span>(data_uncompressed_bytes) <span class="keyword">AS</span> undata_compressed_bytes</span><br><span class="line"><span class="keyword">FROM</span> system.parts;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT 子句中的字段要么出现在 GROUP BY 子句中，要么出现在聚合函数中</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">table</span>, <span class="built_in">count</span>() <span class="keyword">FROM</span> system.parts <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">table</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误的语法，rows 既没有出现在 GROUP BY 中，也没有出现在聚合函数中</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">table</span>, <span class="built_in">count</span>(), <span class="keyword">rows</span>() <span class="keyword">FROM</span> system.parts <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果聚合键对应的列包含 Null 值，那么所有的 Null 会被归为同一组。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155652085-2037142784.png" alt="img"></p>
<p><strong>我们看到所有的 Null 被分为了一组，但是注意：count(字段) 不会把 Null 计算在内，所以直接 count() 就行。</strong></p>
<p><strong>比较简单，但除了上述特性之外，聚合查询还能配合 WITH ROLLUP、WITH CUBE、WITH TOTALS 三种修饰符获取额外的汇总信息。</strong></p>
<h4 id="WITH-ROLLUP"><a href="#WITH-ROLLUP" class="headerlink" title="WITH ROLLUP"></a>WITH ROLLUP</h4><p><strong>测试数据如下：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155645759-481178151.png" alt="img"></p>
<p><strong>以上是普通的 GROUP BY，没什么难的，然后看看它和 WITH ROLLUP 搭配会有什么效果：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155638394-350610817.png" alt="img"></p>
<p><strong>我们注意到，多了四条数据，上面三条，就是按照 product、channel 汇总之后，再单独按 product 汇总，而此时会给对应的 channel 设为零值（这里是空字符串，关系型数据库中为 Null）。同理最后一条数据是全量汇总，不需要指定 product 和 channel，所以显示为 product 和 channel 都显示为零值。我们看到这就相当于按照 product 单独聚合然后再自动拼接在上面了，排好序，并且自动将 channel 赋值为零值，同理最后一条数据也是如此。当然我们也可以写多个语句，然后通过 UNION 也能实现上面的效果，有兴趣可以自己试一下。但是 ClickHouse 提供了 WITH ROLLUP 这个非常方便的功能，我们就要利用好它。</strong></p>
<blockquote>
<p><strong>GROUP BY 子句加上 WITH ROLLUP 选项时，首先按照全部的分组字段进行分组汇总；然后从右往左依次去掉一个分组字段再进行分组汇总，被去掉的字段显示为零值；最后，将所有的数据进行一次汇总，所有的分组字段都显示为零值。</strong></p>
</blockquote>
<h4 id="WITH-CUBE"><a href="#WITH-CUBE" class="headerlink" title="WITH CUBE"></a>WITH CUBE</h4><p><strong>CUBE 代表立方体，它用于对分组字段进行各种可能的组合，能够产生多维度的交叉统计结果，CUBE 通常用于数据仓库中的交叉报表分析。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155630214-2072640677.png" alt="img"></p>
<p><strong>从以上结果可以看出，CUBE 返回了更多的分组数据，其中不仅包含了 ROLLUP 汇总的结果，还包含了相当于按照 channel 进行聚合的记录。因此随着分组字段的增加，CUBE 产生的组合将会呈指数级增长。</strong></p>
<h4 id="WITH-TOTALS"><a href="#WITH-TOTALS" class="headerlink" title="WITH TOTALS"></a>WITH TOTALS</h4><p><strong>WITH TOTALS 反而是最简单的，只包含一个全局汇总的结果。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155623477-1060377326.png" alt="img"></p>
<h2 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h2><p><strong>HAVING 子句要和 GROUP BY 子句同时出现，不能单独使用，它能够在聚合计算之后实现数据的二次过滤。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155618015-611567566.png" alt="img"></p>
<p><strong>对于上面的栗子，使用 WHERE 比使用 HAVING 的效率更高，因为 WHERE 等同于使用了谓词下推，在聚合之前就减少了数据过滤，从而减少了后续聚合时需要处理的数据量。</strong></p>
<p><strong>所以使用 HAVING 进行过滤，那么应该是对聚合之后的结果进行过滤。如果不是聚合之后的，那么使用 WHERE 就好，举个栗子：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155609969-370614629.png" alt="img"></p>
<p><strong>因为 WHERE 的优先级大于 GROUP BY，所以如果按照聚合值进行统计，那么就必须要借助于 HAVING。</strong></p>
<h2 id="ORDER-BY-子句"><a href="#ORDER-BY-子句" class="headerlink" title="ORDER BY 子句"></a>ORDER BY 子句</h2><p><strong>ORDER BY子句通过声明排序键来指定查询数据返回的顺序，通过先前的介绍我们知道，在 MergeTree 表引擎中也有 ORDER BY 参数用于指定排序键，那么这两者有何不同呢？在 MergeTree 中指定 ORDER BY 后，数据在各个分区内会按照其定义的规则排序，这是一种分区内的局部排序。如果在查询时数据跨越了多个分区，则它们的返回顺序是无法预知的，每一次查询返回的顺序都有可能不同。在这种情况下，如果需要数据总是能够按照期望的顺序范围，就需要借助 ORDER BY 子句来指定全局顺序。</strong></p>
<p><strong>ORDER BY 在使用时可以定义多个排序键，每个排序键后需紧跟 ASC（升序）或  DESC（降序）来确定排列顺序。如若不写，则默认为 ASC。例如下面的两条语句即是等价的：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl <span class="keyword">ORDER</span> <span class="keyword">BY</span> v1 <span class="keyword">ASC</span>, v2 <span class="keyword">DESC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl <span class="keyword">ORDER</span> <span class="keyword">BY</span> v1, v2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><strong>数据首先会按照 v1 升序，如果 v1 字段中出现了相同的值，那么再按照 v2 降序。</strong></p>
<p><strong>然后是 Null 值的排序，目前 ClickHouse 有 Null 值最后和 Null 值最前两种策略，可以通过如下进行设置：</strong></p>
<h4 id="1-NULLS-LAST"><a href="#1-NULLS-LAST" class="headerlink" title="1. NULLS LAST"></a>1. NULLS LAST</h4><p><strong>Null 值排在最后，无论升序还是降序，这也是默认的行为。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value -&gt; NaN -&gt; Null</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155600186-1068645033.png" alt="img"></p>
<h4 id="2-NULLS-FIRST"><a href="#2-NULLS-FIRST" class="headerlink" title="2. NULLS FIRST"></a>2. NULLS FIRST</h4><p><strong>Null 值排在最后，无论升序还是降序。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NULL -&gt; NaN -&gt; value</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155551570-1492398706.png" alt="img"></p>
<p><strong>经过测试不难发现，对于 NaN 而言，它总是跟在 Null 的身边。</strong></p>
<h2 id="LIMIT-BY-子句"><a href="#LIMIT-BY-子句" class="headerlink" title="LIMIT BY 子句"></a>LIMIT BY 子句</h2><p><strong>LIMIT BY 子句和大家常见的 LIMIT 有所不同，它运行于 ORDER BY 之后和 LIMIT 之前，它能够按照指定分组，最多返回前 n 行数据（少于 n 行则按照实际数量返回），常用于 TOP N 的查询场景。LIMIT BY 语法规则如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT n BY express</span><br></pre></td></tr></table></figure>

<p><strong>个人觉得这个 LIMIT BY 非常强大，我们举个栗子：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155503458-270715071.png" alt="img"></p>
<p><strong>当然聚合之后没有排序，我们还可以排一下序：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    product,</span><br><span class="line">    channel,</span><br><span class="line">    <span class="built_in">sum</span>(amount) <span class="keyword">AS</span> amount</span><br><span class="line"><span class="keyword">FROM</span> sales_data</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    product,</span><br><span class="line">    channel</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">ASC</span></span><br><span class="line">LIMIT <span class="number">1</span> <span class="keyword">BY</span> channel</span><br></pre></td></tr></table></figure>

<p><strong>此时会选择每个渠道对应的金额最高的数据，当然我们也可以 LIMIT 多条数据、也可以 BY 多个字段。这个功能可以说是非常常用了，我们平时使用的 LIMIT，一般是全局排序之后选择前 N 条数据，而这里的 LIMIT BY 是按照指定的字段分组，然后每一组选择前 N 条数据。</strong></p>
<blockquote>
<p><strong>LIMIT BY 会从上往下在每个组中选择指定条数的数据，因此使用 LIMIT BY 应该同时指定 ORDER BY，否则拿出的数据没有太大意义，除非数据本身就是有序的。</strong></p>
</blockquote>
<p><strong>当然 LIMIT BY 也可以指定偏移量，因为不一定从一条开始选择，而指定偏移量有两种方式：</strong></p>
<ul>
<li><code>LIMIT N OFFSET M BY ...</code></li>
<li><code>LIMIT M, N BY ...</code></li>
</ul>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155452951-107038302.png" alt="img"></p>
<h2 id="LIMIT-子句"><a href="#LIMIT-子句" class="headerlink" title="LIMIT 子句"></a>LIMIT 子句</h2><p><strong>LIMIT 子句用于返回指定的前 N 行数据，常用于分页场景，它的三种语法形式如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIMIT N</span><br><span class="line">LIMIT N <span class="keyword">OFFSET</span> M</span><br><span class="line">LIMIT M, N</span><br></pre></td></tr></table></figure>

<p><strong>用法和 LIMIT BY 中的 LIMIT 一致，如果把 LIMIT BY 中的 BY 去掉，那么就变成了 LIMIT。比较简单，这里用一张图来介绍一下 LIMIT 和 LIMIT BY 之前的关系：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155444441-40300823.png" alt="img"></p>
<p><strong>比较简单，但是在使用 LIMIT 的时候需要注意一点，如果数据跨越了多个分区，那么在没有使用 ORDER BY 指定全局顺序的情况下，每次 LIMIT 查询所返回的数据可能有所不同。如果对返回的数据的顺序比较敏感，则应搭配 ORDER BY 一起使用。</strong></p>
<h2 id="SELECT-和-DISTINCT-子句"><a href="#SELECT-和-DISTINCT-子句" class="headerlink" title="SELECT 和 DISTINCT 子句"></a>SELECT 和 DISTINCT 子句</h2><p><strong>SELECT 子句决定了一次查询语句最终能返回哪些字段或表达式，与直观感受不同，虽然 SELECT 位于 SQL 语句的起始位置，但它的执行的顺序却排在了上面介绍的所有子句的后面。在其它子句执行之后，SELECT 会将选取的字段或表达式作用于每行数据之上，如果使用 * 通配符，则会返回所有字段。但正如开篇所言，大多数情况下都不建议这么做，因为对于一款列式存储数据库而言，这绝对是劣势而不是优势（我们这里在学习的过程就不算了）。</strong></p>
<p><strong>在选择列字段时，ClickHouse 还为特定场景提供了一种基于正则查询的形式，例如下面会选择以 n 开头和包含字母 p 的字段：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COLUMNS(<span class="string">&#x27;^n&#x27;</span>), COLUMNS(<span class="string">&#x27;p&#x27;</span>) <span class="keyword">FROM</span> system.databases</span><br></pre></td></tr></table></figure>

<p><strong>DISTINCT 子句能够去除重复数据，使用场景也很广泛，很多人经常会拿它和 GROUP BY 进行对比：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155436201-311425704.png" alt="img"></p>
<p><strong>虽然顺序不同，但显然结果集的内容是一致的，那么这两者之间有什么区别呢？如果观察它们的执行计划（后面会说）不难发现，DISTINCT 子句的执行计划会更加简单，与此同时，DISTINCT 也能够和 GROUP BY 搭配使用，所以它们是互补而不是互斥的关系。</strong></p>
<p><strong>另外，如果使用了 LIMIT 且没有 ORDER BY 子句，那么 DISTINCT 在满足条件时能够立即结束查询。假设我只需要去重之后的前三条数据，那么 GROUP BY 会对全体数据进行分组，然后再选择前三条；而 DISTINCT 在去重时发现已经有三条了，于是直接返回，后面的数据就不需要看了，因为看了也没意义，LIMIT 决定了只返回三条。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155429111-1453572753.png" alt="img"></p>
<p><strong>两个查询返回的结果集不一样，这是因为 GROUP BY 和 DISTINCT 处理数据的顺序不同。一开始我们就看到了，如果没有 LIMIT，那么两个结果集顺序不同，但内容是一样的，只是这里加了 LIMIT，所以相当于选择了相同内容的不同部分。</strong></p>
<p><strong>如果有 ORDER BY，那么会先执行 DISTINCT，再执行 ORDER BY。并且对于 Null 而言，如果有多个 Null，那么 DISTINCT 之后只会保留一个 Null。</strong></p>
<h2 id="UNION-ALL-子句"><a href="#UNION-ALL-子句" class="headerlink" title="UNION ALL 子句"></a>UNION ALL 子句</h2><p><strong>UNION ALL 子句能够联合左右两边的两组子查询，将结果一并返回。在一次查询中可以声明多次 UNION ALL 以便联合多组查询，但 UNION ALL 不能直接使用其他子句（例如 ORDER BY、LIMIT 等），这些子句只能在它联合的子查询中使用。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, v1 <span class="keyword">FROM</span> union_v1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> title, v1 <span class="keyword">FROM</span> union_v1</span><br></pre></td></tr></table></figure>

<p><strong>对于 UNION ALL 两侧的子查询有以下几点信息：首先，列字段的数量必须相同；其次，列字段的数据类型必须相同或相兼容；最后，列字段的名称可以不同，查询结果中的列名会以左边的子查询为准。</strong></p>
<p><strong>对于联合查询还有一点要说明，目前 ClickHouse 只支持 UNION ALL 子句，如果想得到 UNION DISTINCT 子句的效果，可以使用嵌套查询来变相实现，例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> name, v1 <span class="keyword">FROM</span> union_v1</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> title, v1 <span class="keyword">FROM</span> union_v1</span><br><span class="line">)    </span><br></pre></td></tr></table></figure>

<h2 id="SAMPLE-子句"><a href="#SAMPLE-子句" class="headerlink" title="SAMPLE 子句"></a>SAMPLE 子句</h2><p><strong>SAMPLE 子句能够实现数据采样的功能，使查询仅返回采样数据而不是全部数据，从面有效减少查询负载。SAMPLE 子句的采样机制是一种幂等设计，也就是说在数据不发生变化的情况下，使用相同的采样规则总是能等返回相同的数据，所以这项特性非常适合在那些可以接受近似查询结果的场合使用。例如在数据量十分巨大的情况下，对查询时效性的要求大于准确性时就可以尝试使用 SAMPLE 子句。</strong></p>
<p><strong>SAMPLE 子句只能用于 MergeTree 系列引擎的数据表，并且要求在 CREATE TABLE 时声明 SAMPLE BY 表达式，例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hits_v1 (</span><br><span class="line">    CounterID UInt64,</span><br><span class="line">    EventDate <span class="type">Date</span>,</span><br><span class="line">    UserID UInt64</span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, intHash32(UserID))</span><br><span class="line"><span class="comment">-- SAMPLE BY 声明的表达式必须要包含在主键的声明中</span></span><br><span class="line">SAMPLE <span class="keyword">BY</span> intHash32(UserID)</span><br></pre></td></tr></table></figure>

<p><strong>SAMPLE BY 表示 hits_v1内的数据，可以按照 intHash32(UserID) 分布后的结果采样查询。但需要注意：SAMPLE BY 所声明的表达式必须同时包含在主键的声明内，并且选择的字段必须是 Int 类型，如果不是 ClickHouse 在建表的时候也不会报错，但查询的时候会出异常。</strong></p>
<p><strong>SAMPLE 子句目前支持如下 3 种用法：</strong></p>
<h4 id="1-SAMPLE-factor"><a href="#1-SAMPLE-factor" class="headerlink" title="1. SAMPLE factor"></a>1. SAMPLE factor</h4><p><strong>SAMPLE factor 表示按因子系数采样，其中 factor 表示采样因子，它的取值支持0~1 之间的小数。如果 factor 设置为 0 或者 1，则效果等同于不进行数据采样。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CounterID <span class="keyword">FROM</span> hits_v1 SAMPLE <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<p><strong>factor 也支持使用十进制的形式表述。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CounterID <span class="keyword">FROM</span> hits_v1 SAMPLE <span class="number">1</span> <span class="operator">/</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>如果在进行统计查询时，为了得到最终的近似结果，需要将得到的直接结果乘以采样系数。例如想按照 0.1 的因子采样数据，则需要将统计结果放大 10 倍。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>() <span class="operator">*</span> <span class="number">10</span> <span class="keyword">FROM</span> hits_v1 SAMPLE <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<p><strong>一种更为优雅的方法是借助虚拟字段 _sample_factor 来获取采样系数，并以此代替硬编码的形式，_sample_factor 可以发那会当前查询所对应的采样系数。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>() <span class="operator">*</span> <span class="keyword">any</span>(_sample_factor) <span class="keyword">FROM</span> hits_v1 SAMPLE <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-SAMPLE-rows"><a href="#2-SAMPLE-rows" class="headerlink" title="2. SAMPLE rows"></a>2. SAMPLE rows</h4><p><strong>SAMPLE rows 表示按样本数量采样，其中 rows 表示至少采样多少行数据，它的取值必须是大于 1 的整数。如果 rows 的取值大于表内数据的总行数，则效果等于 rows &#x3D; 1，也就是不使用采样。</strong></p>
<p><strong>比如我们采样 10000 行数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>() <span class="keyword">FROM</span> hits_v1 SAMPLE <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<p><strong>虽然我们采样 10000 行，但是不一定就返回 10000 行，因为数据采样是一个近似范围，这是由于采样数据的最小粒度由 index_granularity 索引粒度所决定的。由此可知，设置一个小于索引粒度或者较小的 rows 没有什么意义，应该设置一个比较大的值。另外，同样可以使用虚拟字段 _sample_factor 来获取当前查询对应的采样系数。</strong></p>
<h4 id="4-SAMPLE-factor-OFFSET-n"><a href="#4-SAMPLE-factor-OFFSET-n" class="headerlink" title="4. SAMPLE factor OFFSET n"></a>4. SAMPLE factor OFFSET n</h4><p><strong>SAMPLE factor OFFSET n 表示按因子系数和偏移量采样，其中 factor 表示采样因子，n 表示偏移多少数据后才开始采样，它们两个的取值都是 0~1 之间的小数。例如下面的语句表示偏移量为 0.5 并按 0.4 的系数采样：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CounterID <span class="keyword">FROM</span> hits_v1 SAMPEL <span class="number">0.4</span> <span class="keyword">OFFSET</span> <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p><strong>上述查询会从数据的二分之一处开始，按照 0.4 的系数采样数据：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155409003-1169057178.png" alt="img"></p>
<p><strong>如果在计算 OFFSET 偏移量后，按照 SAMPLE 比例采样出现了溢出，则数据会被自动截断。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/1229382-20210903155401456-2508167.png" alt="img"></p>
<p><strong>当然这种做法也支持虚拟字段。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>以上就是 ClickHouse 关于查询方面的内容，可以肯定的是内容绝对不止这些，因为和关系型数据库重叠的部分这里自动省略或者一笔带过了，比如空值如何处理（nullif、coalesce）、IN 查询、LIKE 查询、什么是子查询、CASE WHEN 语句等等等等。如果大部分的关系型数据库都支持的语法，那么在 ClickHouse 中基本也是支持的。所以个人觉得有 MySQL 相关经验的话，至少在 ClickHouse 的查询方面，绝对是非常好上手的，没事多写一写就行。</strong></p>
<p><strong>接下来我会介绍 ClickHouse 中关于操作数组的函数，到时候也会刻意地融入更多的语法（这里介绍的，和没有介绍的）。因为 ClickHouse 中提供了大量的函数，通过这些函数 ClickHouse 在处理数据就能够变得所向披靡，但我们不可能一下全说完，这里就先拿数组开刀，因为它相对更复杂一些。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hesay.cn">wenwen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hesay.cn/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/">https://hesay.cn/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hesay.cn" target="_blank">热心市民温温</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ClickHouse/">ClickHouse</a></div><div class="post_share"><div class="social-share" data-image="/img/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ClickHouse 中其它常见的表引擎(八)</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/" title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0(%E5%8D%81%E4%B8%80)/" title="ClickHouse 中的常用聚合函数(十一)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中的常用聚合函数(十一)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中其它常见的表引擎(八)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/" title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E5%85%B6%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%20(%E5%8D%81%E4%BA%94)/" title="ClickHouse 其它的一些操作函数 (十五)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 其它的一些操作函数 (十五)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E%EF%BC%9AMergeTree%20%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E5%85%AD)/" title="ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0(%E5%8D%81%E4%BA%8C)/" title="ClickHouse 字符串的相关操作函数(十二)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 字符串的相关操作函数(十二)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenwen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenlinshan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">码海无涯。。。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ClickHouse-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5-%E4%B9%9D"><span class="toc-number">1.</span> <span class="toc-text">ClickHouse 中的数据查询以及各种子句(九)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WITH-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.2.</span> <span class="toc-text">WITH 子句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">1. 表达式为常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">2. 表达式为函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%BA%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">3. 表达式为子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9C%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%AD%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8WITH"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">4. 在子查询中重复使用WITH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84-WITH-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">其它关系型数据库的 WITH 子句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FROM-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">FROM 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARRAY-JOIN-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.4.</span> <span class="toc-text">ARRAY JOIN 子句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#INNER-ARRAY-JOIN"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">INNER ARRAY JOIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LEFT-ARRAY-JOIN"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">LEFT ARRAY JOIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AA%9A%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">关于数组的一些骚操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">嵌套类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JOIN-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.5.</span> <span class="toc-text">JOIN 子句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">连接精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">连接类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SEMI-%E5%92%8C-ANTI"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">SEMI 和 ANTI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">多表连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WHERE-%E4%B8%8E-PREWHERE-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.6.</span> <span class="toc-text">WHERE 与 PREWHERE 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GROUP-BY-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.7.</span> <span class="toc-text">GROUP BY 子句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WITH-ROLLUP"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">WITH ROLLUP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WITH-CUBE"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">WITH CUBE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WITH-TOTALS"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">WITH TOTALS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HAVING-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.8.</span> <span class="toc-text">HAVING 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORDER-BY-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.9.</span> <span class="toc-text">ORDER BY 子句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-NULLS-LAST"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">1. NULLS LAST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-NULLS-FIRST"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">2. NULLS FIRST</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIMIT-BY-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.10.</span> <span class="toc-text">LIMIT BY 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIMIT-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.11.</span> <span class="toc-text">LIMIT 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SELECT-%E5%92%8C-DISTINCT-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.12.</span> <span class="toc-text">SELECT 和 DISTINCT 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UNION-ALL-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.13.</span> <span class="toc-text">UNION ALL 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SAMPLE-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.14.</span> <span class="toc-text">SAMPLE 子句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-SAMPLE-factor"><span class="toc-number">1.14.0.1.</span> <span class="toc-text">1. SAMPLE factor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SAMPLE-rows"><span class="toc-number">1.14.0.2.</span> <span class="toc-text">2. SAMPLE rows</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-SAMPLE-factor-OFFSET-n"><span class="toc-number">1.14.0.3.</span> <span class="toc-text">4. SAMPLE factor OFFSET n</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.15.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/spring%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1/" title="spring中多线程情况下如何保证事务">spring中多线程情况下如何保证事务</a><time datetime="2023-07-25T07:34:45.332Z" title="发表于 2023-07-25 15:34:45">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0(%E5%8D%81%E4%B8%80)/" title="ClickHouse 中的常用聚合函数(十一)">ClickHouse 中的常用聚合函数(十一)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)">ClickHouse 中其它常见的表引擎(八)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/" title="ClickHouse 中的数据查询以及各种子句(九)">ClickHouse 中的数据查询以及各种子句(九)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/" title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wenwen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>