<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>ClickHouse 的执行计划以及优化策略(十六) | 热心市民温温</title><meta name="author" content="wenwen"><meta name="copyright" content="wenwen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ClickHouse 的执行计划以及优化策略(十六)​																	本文来源： ( https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;tag&#x2F;ClickHouse：一款速度快到让人发指的列式存储数据库&#x2F; )   执行计划如果要在 ClickHouse 20.6 版本之前查看 SQL 语句的执行计划，需要在 config.xml 里面将日志级别设置为 tra">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse 的执行计划以及优化策略(十六)">
<meta property="og:url" content="https://hesay.cn/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/index.html">
<meta property="og:site_name" content="热心市民温温">
<meta property="og:description" content="ClickHouse 的执行计划以及优化策略(十六)​																	本文来源： ( https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;tag&#x2F;ClickHouse：一款速度快到让人发指的列式存储数据库&#x2F; )   执行计划如果要在 ClickHouse 20.6 版本之前查看 SQL 语句的执行计划，需要在 config.xml 里面将日志级别设置为 tra">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hesay.cn/img/favicon.png">
<meta property="article:published_time" content="2023-04-11T09:04:31.000Z">
<meta property="article:modified_time" content="2023-04-13T09:06:57.974Z">
<meta property="article:author" content="wenwen">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hesay.cn/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hesay.cn/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ClickHouse 的执行计划以及优化策略(十六)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-13 17:06:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="热心市民温温"><span class="site-name">热心市民温温</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">ClickHouse 的执行计划以及优化策略(十六)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-13T09:06:57.974Z" title="更新于 2023-04-13 17:06:57">2023-04-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ClickHouse/">ClickHouse</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ClickHouse 的执行计划以及优化策略(十六)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="ClickHouse-的执行计划以及优化策略-十六"><a href="#ClickHouse-的执行计划以及优化策略-十六" class="headerlink" title="ClickHouse 的执行计划以及优化策略(十六)"></a>ClickHouse 的执行计划以及优化策略(十六)</h1><p>​																	本文来源： ( <a target="_blank" rel="noopener" href="https://www.cnblogs.com/traditional/tag/ClickHouse%EF%BC%9A%E4%B8%80%E6%AC%BE%E9%80%9F%E5%BA%A6%E5%BF%AB%E5%88%B0%E8%AE%A9%E4%BA%BA%E5%8F%91%E6%8C%87%E7%9A%84%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93/">https://www.cnblogs.com/traditional/tag/ClickHouse：一款速度快到让人发指的列式存储数据库/</a> ) </p>
<hr>
<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p><strong>如果要在 ClickHouse 20.6 版本之前查看 SQL 语句的执行计划，需要在 config.xml 里面将日志级别设置为 trace。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新版本默认是 trace --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span>&gt;</span>trace<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>然后还要真正执行相应的 SQL 语句，在执行日志里面查看，很明显这是非常不方便的。于是 ClickHouse 在 20.6 版本里面引入了原生的执行计划的语法（此时处于试用期阶段），并在 20.6.3 版本中正式转正。</strong></p>
<blockquote>
<p><strong>我们当前系列都是基于 ClickHouse 的 21.7.3.14 版本。</strong></p>
</blockquote>
<p><strong>然后我们来介绍如何查看执行计划，不过介绍之前我们先创建一张数据表，这次我们采用真实的数据。首先 ClickHouse 官方提供了两个数据集，其中数据行数和字段数都非常的大，不亚于一些公司生产环境上的数据，我们来下载一下。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载数据集，这里的数据集不是 CSV、JSON，而是 .bin、.mrk 等物理文件</span></span><br><span class="line"><span class="comment"># 也就是说数据集本身就是符合 ClickHouse 物理存储的</span></span><br><span class="line">curl -O https://datasets.clickhouse.tech/hits/partitions/hits_v1.tar</span><br><span class="line"><span class="comment"># 所以我们直接解压到拷贝到 /var/lib/clickhouse 目录下即可</span></span><br><span class="line">tar -xvf hits_v1.tar -C /var/lib/clickhouse</span><br></pre></td></tr></table></figure>

<p><strong>然后我们就可以使用 hits_v1 这张表了，我们之前说过，必须要先创建表然后再导入数据，因为创建表的时候会生成一些元信息，存储在 &#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;metadata 目录下，而光有数据没有元信息是不行的。但对于当前而言则不用事先创建表，因为 ClickHouse 将元信息也准备好了，所以我们直接拷贝过去即可。压缩包解压之后，会有一个 data 目录和一个 metadata 目录，所以我们解压到 &#x2F;var&#x2F;lib&#x2F;clickhouse 中，会自动将 data 目录里面的内容合并到 &#x2F;var&#x2F;lib&#x2F;clickhouse 的 data 目录中，将 metadata 目录里面的内容合并到 &#x2F;var&#x2F;lib&#x2F;clickhouse 的 metadata 目录中。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@satori data]<span class="comment"># ls</span></span><br><span class="line">datasets  default  system</span><br><span class="line">[root@satori data]<span class="comment"># ls datasets</span></span><br><span class="line">hits_v1</span><br></pre></td></tr></table></figure>

<p><strong>我们看到里面多了一个 datasets 目录，datasets 目录下才是 hits_v1，显然我们后续需要使用 datasets.hits_v1 进行查询。当然数据集还有一份，我们按照相同的套路即可。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="operator">-</span>O https:<span class="operator">/</span><span class="operator">/</span>datasets.clickhouse.tech<span class="operator">/</span>visits<span class="operator">/</span>partitions<span class="operator">/</span>visits_v1.tar</span><br><span class="line">tar <span class="operator">-</span>xvf visits_v1.tar <span class="operator">-</span>C <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>clickhouse</span><br></pre></td></tr></table></figure>

<p><strong>我们来确认一下：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@satori datasets]<span class="comment"># ls</span></span><br><span class="line">hits_v1  visits_v1</span><br></pre></td></tr></table></figure>

<p><strong>显然数据集已经准备完毕，不过我们当前使用的是 root 用户，还应该要确保 clickhouse 用户有相应的操作权限。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> clickhouse:clickhouse /var/lib/clickhouse/data -R</span><br><span class="line"><span class="comment"># 然后重启 ClickHouse，因为我们不是通过 CREATE TABLE 创建的表</span></span><br><span class="line"><span class="comment"># 因此要重启，不然 ClickHouse 是不知道我们通过拷贝文件的方式新增了两张表</span></span><br><span class="line">clickhouse restart</span><br></pre></td></tr></table></figure>

<p><strong>重启之后，执行 SQL 语句进行查看：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913183943809-487548377.png" alt="img"></p>
<p><strong>数据量还是不少的，datasets.hits_v1 有将近 900 万条数据、字段数 130 多个，datasets.visit_v1 有 160 多万条数据、字段数为 180 多个，还是很大的。</strong></p>
<blockquote>
<p><strong>具体都有哪些字段，可以通过 &#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;metadata&#x2F;datasets 下的 .sql 文件进行查看。</strong></p>
</blockquote>
<p><strong>有了数据集，我们就可以介绍查询计划了。当然使用这种规模的数据集有些小题大做，不过既然 ClickHouse 是为大数据准备的，那么使用大一点的数据集也无妨，而且我们后面也会经常使用这些数据集。</strong></p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><strong>在 MySQL 中查看执行计划使用的语法是什么呢？没错，EXPLAIN，在 ClickHouse 中也是如此，只不过 ClickHouse 将 EXPLAIN 变得更加丰富。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAN [AST <span class="operator">|</span> SYNTAX <span class="operator">|</span> PLAN <span class="operator">|</span> PIPELINE] [SETTINGS <span class="operator">=</span> <span class="keyword">value</span>, ...]</span><br><span class="line"><span class="keyword">SELECT</span> ... [FORMAT ...]</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下第一个中括号里面的内容，ClickHouse 除了可以让我们查看执行计划之外，还可以查看很多其它内容。</strong></p>
<p><strong>1）AST：查看编译之后的语法树，这个不是很常用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN AST</span><br><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>() <span class="keyword">FROM</span> datasets.hits_v1 </span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">&lt;</span> toDate(<span class="string">&#x27;2014-03-17&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID;</span><br></pre></td></tr></table></figure>

<p><strong>执行一下，查看生成的语法树：</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913183954791-1357266678.png" alt="img"></p>
<p><strong>2）SYNTAX：用于优化语法，有时我们指定的查询语句未必是最优的，那么 ClickHouse 在底层会进行优化，EXPLAIN SYNTAX 可以返回对一条 SQL 语句进行优化后的结果。通过对比优化前和优化后的 SQL 语句，可以有助于我们理解 ClickHouse 的优化机制</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>() count <span class="keyword">FROM</span> datasets.hits_v1 </span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">&lt;</span> toDate(<span class="string">&#x27;2014-03-17&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID <span class="keyword">ORDER</span> <span class="keyword">BY</span> count LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184005381-91963819.png" alt="img"></p>
<p><strong>我们看到仅仅是做了一些格式上调整，但优化前和优化后的语句本质上没差别，证明对于当前查询而言，我们写的 SQL 语句就是最优的。因为这条语句太简单了，ClickHouse 没有什么可优化的。</strong></p>
<p><strong>然后我们来写几个非常规的语句，比如三元表达式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这是嵌套的三元表达式，那么 ClickHouse 会怎么优化呢?</span></span><br><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> number <span class="operator">&lt;</span> <span class="number">5</span> ? <span class="string">&#x27;小于 5&#x27;</span> : (number <span class="operator">=</span> <span class="number">5</span> ? <span class="string">&#x27;等于 5&#x27;</span> : <span class="string">&#x27;大于 5&#x27;</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184026557-163630040.png" alt="img"></p>
<p><strong>注意：这里并没有开启优化，只不过是将三元表达式使用 if 语句替换了，因为没有嵌套的三元表达式在底层就是对应 if 函数的一个调用。只不过 ClickHouse 将一些比较特殊的函数调用，抽象成了一些语法糖，但本质上是没有变化的，所以当前的 SQL 语句并没有得到优化。</strong></p>
<p><strong>事实上，ClickHouse 对三元表达式的优化默认是关闭的，我们可以将其打开。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 见名知意，就是当出现 if 的嵌套时，优化成 multiIf</span></span><br><span class="line"><span class="keyword">SET</span> optimize_if_chain_to_multiif <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184036739-210277828.png" alt="img"></p>
<p><strong>SYNTAX 还是很常用的，我们写完一条 SQL 语句之后，可以直接 EXPLAIN SYNTAX 一下，然后将返回的结果替换掉我们原来的 SQL 语句。</strong></p>
<p><strong>PLAN：查看执行计划，默认选项</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>() count <span class="keyword">FROM</span> datasets.hits_v1 </span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">&lt;</span> toDate(<span class="string">&#x27;2014-03-17&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID <span class="keyword">ORDER</span> <span class="keyword">BY</span> count LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184015646-1560810255.png" alt="img"></p>
<p><strong>我们看到图中的 EXPLAIN 后面并没有带上 PLAN，说明 PLAN 是默认选项，然后查看执行计划时还可以设置一些额外的参数：</strong></p>
<ul>
<li><code>header：打印计划中各个步骤的 head 说明，默认值为 0 表示关闭，如果开启，设置为 1</code></li>
<li><code>description：打印计划中各个步骤的描述，就是图中括号里面的部分，默认值为 1 表示开启，如果关闭，设置为 0</code></li>
<li><code>actions：打印计划中各个步骤的详细信息，默认值为 0 表示关闭，如果开启，设置为 1</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN header <span class="operator">=</span> <span class="number">1</span>, actions <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>() count <span class="keyword">FROM</span> datasets.hits_v1 </span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">&lt;</span> toDate(<span class="string">&#x27;2014-03-17&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID <span class="keyword">ORDER</span> <span class="keyword">BY</span> count LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>输出的内容非常多，可以测试一下。</strong></p>
<p><strong>PIPELINE：查看 PIPELINE 计划，类似于 PLAN</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PIPELINE <span class="keyword">SELECT</span> <span class="built_in">sum</span>(number) <span class="keyword">FROM</span> numbers(<span class="number">100000</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> number <span class="operator">%</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184048889-202343307.png" alt="img"></p>
<p><strong>类似于 PLAN，查看 PIPELINE 计划时还可以设置一些额外的参数：</strong></p>
<ul>
<li><code>header：打印计划中各个步骤的 head 说明，默认值为 0 表示关闭，如果开启，设置为 1</code></li>
<li><code>graph：用 DOT 图形语言描述管道图，默认关闭，</code></li>
<li><code>actions：表示当开启 graph 之后是否紧凑打印，默认开启</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PIPELINE header <span class="operator">=</span> <span class="number">1</span>, graph <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(number) <span class="keyword">FROM</span> numbers(<span class="number">100000</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> number <span class="operator">%</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><strong>可以自己查看一下输出。</strong></p>
<h3 id="建表优化"><a href="#建表优化" class="headerlink" title="建表优化"></a>建表优化</h3><p><strong>我们在创建表的时候，需要指定的内容比较多，比如 ORDER BY、表引擎、表参数、分区字段等等，这些对后续数据的查询效率都是有影响的，当然指定合适的数据类型也是非常重要的。下面就来介绍一下常见的优化手段。</strong></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>在建表的时候能用数值类型和日期时间类型表示的字段就不要使用字符串，虽然字符串类型在以 Hive 为中心的数仓建设中非常常见，但 ClickHouse 却并非如此。我们知道在 Hive 中，日期一般都用字符串，不会特意使用 Date 类型。但在 ClickHouse 中，能不要 String 就不要用，因为后期还要转换。</strong></p>
<p><strong>对于 DateTime，ClickHouse 底层会转成时间戳进行存储，但我们不要显式地使用 UInt64 类型来存储。因为 DateTime 不需要经过函数转换处理，执行效率高，可读性好。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_t (</span><br><span class="line">    id UInt32,</span><br><span class="line">    product String,</span><br><span class="line">    amount <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    create_time UInt32  <span class="comment">-- 这里使用了整数存储时间</span></span><br><span class="line">) ENGINE <span class="operator">=</span> ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(toDate(create_time))  <span class="comment">-- 需要转换一次，否则报错</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>

<p><strong>除了日期类型和数值类型不用字符串表示之外，Null 也是拖累性能的一个罪魁祸首，因为官方已经指出 Null 会影响性能了。因为存储 Nullable 类型的列时，需要创建一个额外的文件来存储 Null 标记，并且 Nullable 类型的列无法被索引。因此除了极特殊的情况，否则不要将列设置为 Nullable，可以用一个不可能出现的默认值、或者在业务中无意义的来代指空，例如将 id 设置为 -1 表示该商品没有 id，而不是使用 Null。</strong></p>
<h4 id="分区和索引"><a href="#分区和索引" class="headerlink" title="分区和索引"></a>分区和索引</h4><p><strong>分区粒度根据业务特点决定，但不宜过粗或者过细，如果数据之间是严格按照时间来划分，比如经常要按天、按月或者按年汇总处理，那么不妨选择按天分区或者按月分区；如果数据按照地区来划分，比如经常针对不同的地区单独汇总，那么不妨按照地区分区。那么分区到底要分多少个区呢？以单表一亿条数据为例，分区大小控制在 10 到 30 个最好。所以如果按照时间分区，那么我们一般都会按天、按月分区，至于按分钟分区则 dark不必，因为这样分区目录就太多了。</strong></p>
<p><strong>还有指定索引列，默认通过 ORDER BY 指定。ORDER BY 在 ClickHouse 中是最重要的，因为分区内的排序通过 ORDER BY 指定，主键（索引）默认也是由 ORDER BY 指定，即使我们显式地使用 PRIMARY KEY 不使用 ORDER BY，那么主键也必须是排序键的前缀。当然这里的 ORDER BY 指的是建表时的 ORDER BY，不是查询语句中的 ORDER BY。</strong></p>
<p><strong>然后我们在通过 ORDER BY 指定索引列的时候，应该指定查询中经常被用来充当筛选条件的列，可以是单一维度，也可以是组合维度，如果是组合维度，那么索引列要满足查询频率大的在前原则。还有基数特别大的不适合做索引列，基数大指的就是那些重复数据非常少的列。</strong></p>
<h4 id="表参数"><a href="#表参数" class="headerlink" title="表参数"></a>表参数</h4><p><strong>index_granularity 是用来控制索引粒度的，默认是 8192，如非必须不建议调整。另外，如果一张表不是必须要保留全量历史数据，则建议指定 TTL，可以免去手动清理过期历史数据的麻烦，TTL 也可以通过 ALTER TABLE 语句随时修改。</strong></p>
<h4 id="写入和删除优化"><a href="#写入和删除优化" class="headerlink" title="写入和删除优化"></a>写入和删除优化</h4><p><strong>尽量不要执行单条或小批量删除、插入操作，这样会产生小分区文件，给后台 Merge 任务带来巨大压力。</strong></p>
<p><strong>不要一次写入太多分区，或者数据写入太快，数据写入太快会导致 Merge 速度跟不上而报错，一般建议每秒钟发起 2 ~ 3 此写入操作，每次操作写入 2w ~ 5 w 条数据（依服务器性能而定）。</strong></p>
<h4 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h4><p><strong>我们知道配置文件位于 &#x2F;etc&#x2F;clickhouse-server 目录下，里面有 config.xml 和 users.xml，我们之前一直说 config.xml，但其实 users.xml 也非常重要。它们都表示服务端的配置，而区别主要在于 config.xml 里面的配置是无法覆盖的，我们在命令行经常会使用 set 命令将某个参数进行修改，这些参数则是放在 users.xml 中。当然一个设置即可以在 users.xml 中出现，也可以在 config.xml 中出现，服务端首先会从 config.xml 中找，找不到再去 config.xml 中找。</strong></p>
<p><strong>而我们修改配置主要是为了调整 CPU、内存、IO，瓶颈主要在这里。因为 ClickHouse 会有后台线程 Merge 数据，所以非常的吃 CPU；当然加载数据，对内存也是一个考量；同理还有 IO，因为要从磁盘上读取大量数据。</strong></p>
<p><strong>下面来介绍与这三个配置有关的参数。</strong></p>
<p><strong>1）CPU</strong></p>
<p><strong>background_pool_size：位于 users.xml 中，非常重要的一个参数，表示后台线程池内的线程数量，Merge 线程就是在该线程池中执行，该线程池不仅仅是给 Merge 线程用的。默认值为 16，允许的前提下建议改成 CPU 个数的二倍。所以 ClickHouse 不建议和 HDFS、Yarn 等一起部署，因为 ClickHouse 太吃资源了，不然也达不到如此可观的速度</strong></p>
<p><strong>background_schedule_pool_size：位于 users.xml 中，表示执行后台任务的线程数，默认值为 128，允许的前提下建议改成 CPU 个数的二倍</strong></p>
<p><strong>background_distributed_schedule_pool_size：位于 users.xml 中，表示分布式发送执行后台任务的线程数，默认值为 16，允许的前提下建议改成 CPU 个数的二倍</strong></p>
<p><strong>max_concurrent_queries：位于 config.xml 中，表示最大并发处理的请求数（包含 SELECT、INSERT 等等），默认值为 100，推荐 150 ~ 300，不够再加</strong></p>
<p><strong>max_threads：位于 users.xml 中，表示单个查询所能使用的最大 CPU 个数，默认是 CPU 核数</strong></p>
<p>**以上是关于 CPU 相关的设置，如果发现机器吃不消了，那么不妨减少一下线程数。 **</p>
<p><strong>2）Memory</strong></p>
<p><strong>max_memory_usage：位于 users.xml 中，表示单次 Query 占用内存的最大值，该值可以设置的大一些，这样可以提高集群查询的上限。当然也要保留一些给 OS，比如 128G 的内存，设置为 100G 即可</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184101340-936437929.png" alt="img"></p>
<p><strong>max_bytes_before_external_group_by：表示 GROUP BY 使用的内存的最大值，一旦超过这个最大值，那么会刷新到磁盘进行 GROUP BY，一般按照 max_memory_usage 的一半设置即可。因为 ClickHouse 聚合分两个阶段，查询并建立中间数据、合并中间数据</strong></p>
<p><strong>max_bytes_before_external_sort：表示 ORDER BY 使用的内存的最大值，一旦超过这个最大值，那么会刷新到磁盘进行 ORDER BY。如果不设置该值，那么当内存不够的时候直接报错，设置了该值，ORDER BY 在内存不够的时候可以基于磁盘完成，但是速度相对就慢了（实际测试发现慢得多，甚至无法接受）。该参数和上一个参数都在 users.xml 中设置。</strong></p>
<p><strong>max_table_size_to_drop：位于 config.xml 中，应用于需要删除表或分区的情况，默认是 50 GB，意思是如果删除 50 GB 以上的数据会失败。建议设置为 0，表示无论分区表 多大都可以删除</strong></p>
<p><strong>3）IO</strong></p>
<p><strong>和 HDFS 不同，ClickHouse 不支持设置多数据目录，为了提升 IO 性能，可以挂载虚拟券组（将多块磁盘虚拟成一块磁盘），通过一个券组绑定多块物理磁盘提升读写性能。或者使用 SSD，但是成本就比较高了。</strong></p>
<h3 id="ClickHouse-语法优化规则"><a href="#ClickHouse-语法优化规则" class="headerlink" title="ClickHouse 语法优化规则"></a>ClickHouse 语法优化规则</h3><p><strong>很多数据库底层都内置了优化器，定义好了许多的优化规则，用于给我们的 SQL 语句进行优化，比如大小表 JOIN、谓词下推等等，就是为了避免开发人员执行慢查询。</strong></p>
<p><strong>那么 ClickHouse 会对哪些查询进行优化呢？我们来看一下。</strong></p>
<h4 id="COUNT-优化"><a href="#COUNT-优化" class="headerlink" title="COUNT 优化"></a>COUNT 优化</h4><p><strong>我们说如果统计一张表有多少行，那么使用 count() 或者 count(*) 即可，此时会直接读取 count.txt。还记得这个 count.txt 文件吗？我们在介绍 MergeTree 的时候说过，该文件里面存储了表的行数，当使用 count() 或者 count(*) 的时候，直接读取该文件即可，此时是不需要全表扫描的。类似于关系型数据库也是如此，MySQL 在使用 count() 的时候也是直接计算的 B+ 树的叶子结点个数。</strong></p>
<p><strong>但当我们 count 一个字段的时候，那么就必须要全表扫描了，而且我们说过 count 字段的时候统计的是该字段中非空的值的个数。如果该字段中没有空值，count(字段) 的结果和 count()、count(*) 是相等的。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184112282-99248751.png" alt="img"></p>
<p><strong>对比输出信息的话，我们看到 count(字段) 进行了全表扫描。</strong></p>
<p><strong>再比如 count(1)，我们看看它会不会被优化：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">satori :) EXPLAIN SYNTAX <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line"></span><br><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"></span><br><span class="line">Query id: f59337ec<span class="number">-58e3</span><span class="number">-4</span>a37<span class="operator">-</span>b00d<span class="operator">-</span>eaa796f54f65</span><br><span class="line"></span><br><span class="line">┌─explain───────────────┐</span><br><span class="line">│ <span class="keyword">SELECT</span> <span class="built_in">count</span>()        │</span><br><span class="line">│ <span class="keyword">FROM</span> datasets.hits_v1 │</span><br><span class="line">└───────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.004</span> sec.</span><br></pre></td></tr></table></figure>

<p><strong>因为 1 是一个整型，没有什么实际意义，所以直接变成了 count()。</strong></p>
<h4 id="谓词下推"><a href="#谓词下推" class="headerlink" title="谓词下推"></a>谓词下推</h4><p><strong>在 SQL 中，谓词就是返回 boolean 值的函数，或隐式转换为 bool 的函数，说白了你就简单理解为 WHERE 语句即可。而谓词下推指的是将过滤表达式尽可能移动至靠近数据源的位置，从事后过滤变成事前过滤。</strong></p>
<p><strong>举个最简单的栗子就是 WHERE 和 HAVING，我们知道 WHERE 是发生在 GROUP BY 之前的，HAVAING 发生在 GROUP BY 之后。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>() <span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID <span class="keyword">HAVING</span> UserID <span class="operator">=</span> <span class="number">1785640464950496314</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">┌──────────────UserID─┬─count()─┐</span></span><br><span class="line"><span class="comment">│ 1785640464950496314 │     105 │</span></span><br><span class="line"><span class="comment">└─────────────────────┴─────────┘</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>上面这行 SQL 语句执行的时候虽然没有任何问题，但很明显这是一个糟糕的 SQL 语句，因为要先对将近 900 万的数据进行聚合，然后选择 UserID 为 1785640464950496314 的记录。既然如此，那我们为什么不能先把 UserID 为 1785640464950496314 的记录选出来，然后再单独进行聚合呢？这样的话数据量会少很多。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184209516-1021848259.png" alt="img"></p>
<p><strong>我们看到在优化之后的 SQL 语句将条件从 HAVING 移到了 WHERE，所以将过滤表达式尽可能移动至靠近数据源的位置，在计算之前先将无用数据过滤掉，这个过程就是谓词下推。</strong></p>
<p><strong>当然谓词下推不仅仅是这里的 HAVING，子查询也支持，举个栗子，我们要根据 UserID 从 hits_v1 表中查询几个用户的记录，但是这些值必须存在于 visits_v1 的 UserID 字段中。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, URL <span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="keyword">IN</span> (<span class="number">329024891984319329</span>, <span class="number">3341630990649416532</span>, <span class="number">3444082748272603552</span>);</span><br></pre></td></tr></table></figure>

<p><strong>显然这是非常简单的，但如果我们规定 UserID 还必须要出现在 visits_v1 表的 UserID 字段中，那么要怎么做呢？最简单的做法就是一个条件即可。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, URL</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="keyword">IN</span> (<span class="number">329024891984319329</span>, <span class="number">3341630990649416532</span>, <span class="number">3444082748272603552</span>)</span><br><span class="line">  <span class="keyword">AND</span> UserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> datasets.visits_v1);</span><br></pre></td></tr></table></figure>

<p><strong>但很明显这条语句就不是最优解，因为子查询会扫描全表，也就是 visits_v1 会全量读取。既然 UserID 要在两个表中都出现，那么就应该优先把过滤条件放在子查询里面。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, URL</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="keyword">IN</span></span><br><span class="line">      (<span class="keyword">SELECT</span> UserID  <span class="comment">-- 数据量大的话，还可以进行去重</span></span><br><span class="line">       <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">       <span class="keyword">WHERE</span> UserID <span class="keyword">IN</span> (<span class="number">329024891984319329</span>, <span class="number">3341630990649416532</span>, <span class="number">3444082748272603552</span>));</span><br></pre></td></tr></table></figure>

<p><strong>这种做法显然更优，因为 visits_v1 不需要全量读取，但 ClickHouse 目前还做不了这种优化，ClickHouse 所能做的子查询谓词下推还是很有限的。当然不光是子查询，相比 Hive，ClickHouse 所做的优化非常有限，不同的 SQL 语句效率相差十倍以上都是很正常的，因为我们写 SQL 就不可以肆无忌惮。</strong></p>
<h4 id="作为表进行-JOIN-的子查询会消除重复字段"><a href="#作为表进行-JOIN-的子查询会消除重复字段" class="headerlink" title="作为表进行 JOIN 的子查询会消除重复字段"></a>作为表进行 JOIN 的子查询会消除重复字段</h4><p><strong>如果子查询中重复选择了某个字段，那么当它作为表进行 JOIN 的时候，会去除重复字段。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> a.UserID, b.VisitID, a.URL</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> UserID, UserID, VisitID</span><br><span class="line">    <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">) b</span><br><span class="line"><span class="keyword">USING</span>(UserID) LIMIT <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>这里进行 JOIN 的右表是一个子查询，而在这个子查询里面我们选择了两次 UserID，那么 ClickHouse 会进行优化，变成只选择一次。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184200192-1452223116.png" alt="img"></p>
<p><strong>可能有人好奇，如果我给第二个 UserID 起一个别名会怎么样呢？答案是即使起了别名，仍然只会选择一次。</strong></p>
<p><strong>注意：这里的子查询在 JOIN 的时候会删除重复字段，但如果不是在 JOIN 的时候就不一样了。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> UserID, URL</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> UserID, UserID, URL</span><br><span class="line">    <span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">) LIMIT <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>这里的子查询当中我们选择了两个 UserID，那么 ClickHouse 会不会变成一个呢？</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184254606-1791960429.png" alt="img"></p>
<p><strong>我们看到并没有优化掉，所以 ClickHouse 所做的优化还是比较有限的。</strong></p>
<h4 id="聚合计算外推"><a href="#聚合计算外推" class="headerlink" title="聚合计算外推"></a>聚合计算外推</h4><p><strong>什么是聚合计算外推呢？举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(RequestNum <span class="operator">*</span> <span class="number">2</span>) <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<p><strong>你觉得上面的 SQL 有能够优化的地方吗？我们看看 ClickHouse 是如何做的。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184219260-1916876794.png" alt="img"></p>
<p><strong>没优化的时候，相当于是在 sum 之前先给每一条数据做一次乘法运算，然后进行 sum；优化之后则是先进性 sum，最后只对总和进行一次乘法运算，显然后者更优。</strong></p>
<h4 id="聚合函数消除"><a href="#聚合函数消除" class="headerlink" title="聚合函数消除"></a>聚合函数消除</h4><p><strong>我们在使用 GROUP BY 的时候有一个限制，那就是 SELECT 中没有使用聚合函数的字段必须出现在分组字段中。举几个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字段 b 出现在了 SELECT 中，并且没有使用聚合函数，所以它一定要出现在分组字段（GROUP BY）中</span></span><br><span class="line"><span class="comment">-- 但没有出现，所以报错</span></span><br><span class="line"><span class="keyword">SELECT</span> a, b, <span class="built_in">count</span>(c) <span class="keyword">FROM</span> t <span class="keyword">GROUP</span> <span class="keyword">BY</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时没有问题，a 和 b 都出现在 GROUP BY 中</span></span><br><span class="line"><span class="comment">-- 至于字段 c，它是以 count(c) 的形式出现的，使用了聚合函数，所以没问题</span></span><br><span class="line"><span class="keyword">SELECT</span> a, b, <span class="built_in">count</span>(c) <span class="keyword">FROM</span> t <span class="keyword">GROUP</span> <span class="keyword">BY</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这条语句也是非法的，因为 b 没有出现在 GROUP BY 中，至于 count(b) 和 b 无关</span></span><br><span class="line"><span class="comment">-- 既然 SELECT 中出现了没有使用聚合函数的字段 b，那么它就必须要出现在 GROUP BY 中</span></span><br><span class="line"><span class="keyword">SELECT</span> a, b, <span class="built_in">count</span>(b), <span class="built_in">count</span>(c) <span class="keyword">FROM</span> t <span class="keyword">GROUP</span> <span class="keyword">BY</span> a;</span><br></pre></td></tr></table></figure>

<p><strong>当然这些属于基础内容了，我主要想表达的是，我们可不可以对分组字段使用聚合函数呢？比如说：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">max</span>(UserID), <span class="built_in">max</span>(Age), <span class="built_in">min</span>(Age), <span class="built_in">sum</span>(Age) <span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> Age</span><br></pre></td></tr></table></figure>

<p><strong>很明显是可以的，但是这么做没有任何意义，因为分组就是把分组字段对应的值相同的归为一组，比如这里的 age，所以每一组的 age 的值都是一样的。既然都一样，那么做聚合就没有太大意义，因此 ClickHouse 会那些对分组字段使用 min、max、any 的聚合函数给删掉。因为每一组的所有值都是一样的，最小值、最大值、第一行的值，三者之间没差别。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184230618-757781969.png" alt="img"></p>
<p><strong>我们看到聚合函数 min、max 被剥掉了，只留下了 Age 字段，因为分组字段的值都是一样的，min、max、any 没有意义。但聚合函数仅限于 max、min、any，如果是 sum 就不会了，虽然从业务的角度上来说也没有太大意义，但毕竟 sum 涉及到加法运算，所以它不会被剥掉。</strong></p>
<h4 id="删除重复的-ORDER-BY-KEY"><a href="#删除重复的-ORDER-BY-KEY" class="headerlink" title="删除重复的 ORDER BY KEY"></a>删除重复的 ORDER BY KEY</h4><p><strong>类似于消除重复字段，如果指定了多个相同的排序字段，那么只会保留一个。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX <span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> datasets.hits_v1 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age, Age, Age <span class="keyword">DESC</span>, Age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184305683-1408761507.png" alt="img"></p>
<p><strong>我们看到即使不同的排序，也会只保留相同排序字段的第一个，因为同一个字段即升序又降序本身就很奇怪。</strong></p>
<h4 id="删除重复的-LIMIT-BY-KEY"><a href="#删除重复的-LIMIT-BY-KEY" class="headerlink" title="删除重复的 LIMIT BY KEY"></a>删除重复的 LIMIT BY KEY</h4><p><strong>还记得 LIMIT BY 吗？”LIMIT N BY 字段” 表示按照字段进行分组，然后选出每组的前 N 条数据。如果 BY 后面的字段重复了，那么也会删除掉。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX <span class="keyword">SELECT</span> UserID, URL <span class="keyword">FROM</span> datasets.hits_v1 </span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">BY</span> UserID, UserID</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184316965-1106004376.png" alt="img"></p>
<h4 id="删除重复的-USING-KEY"><a href="#删除重复的-USING-KEY" class="headerlink" title="删除重复的 USING KEY"></a>删除重复的 USING KEY</h4><p><strong>USING 也是如此，直接看例子吧。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> a.UserID, a.UserID, b.VisitID, a.URL, b.UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v1 b <span class="keyword">USING</span>(UserID, UserID);</span><br></pre></td></tr></table></figure>

<p><strong>USING 里面指定了两个 UserID，那么会变成一个。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184328254-1163018829.png" alt="img"></p>
<p><strong>USING 里面指定了两个 UserID，那么会变成一个，即使我们指定了前缀，比如 USING(a.UserID, b.UserID)，那么依旧会被优化成一个 UserID。</strong></p>
<p><strong>但是说实话，删除重复的 ORDER BY KEY、LIMIT BY KEY、USING KEY，正常情况下很难出现，因为谁会没事故意将一个字段重复写两遍啊。当然字段多了倒是有可能发生，因为字段一多就可能忘记某个字段已经写过一遍了，但是字段少的情况下几乎不可能发生。</strong></p>
<p><strong>所以这个 ClickHouse 的优化机制有点把人当傻子，大概感觉就是当你写了一个 1 + 1 &#x3D; 3，那么它能帮你改成 1 + 1 &#x3D; 2，然而查询一旦复杂，它就无法优化了。所以一切还需要我们来保证，当然后续 ClickHouse 的优化机制会变得越来越完善。</strong></p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p><strong>这个主要体现在 WITH 子句上面，我们最开始介绍 WITH 子句的时候说过，WITH 子句可以给一个普通的表达式赋值，也可以给一个查询赋值，但查询只能返回一行数组。最终会将其作为一个标量，后续查询时直接用这个标量进行替换即可。这背后也是 ClickHouse 给我们做的优化，举个例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> (<span class="keyword">SELECT</span> <span class="built_in">sum</span>(data_uncompressed_bytes) <span class="keyword">FROM</span> system.columns) <span class="keyword">AS</span> total_bytes</span><br><span class="line"><span class="keyword">SELECT</span> database, </span><br><span class="line">       (<span class="built_in">sum</span>(data_uncompressed_bytes) <span class="operator">/</span> total_bytes) <span class="operator">*</span> <span class="number">100</span> <span class="keyword">AS</span> database_disk_usage</span><br><span class="line"><span class="keyword">FROM</span> system.columns</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> database</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> database_disk_usage <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p><strong>注意 WITH 语句中的 total_bytes，它是对 data_uncompressed_bytes 进行 sum 所得到的结果，如果在查询中多次使用 total_bytes，那么难道每次都要计算一遍吗？显然不是的，这个值是提前算好的，是一个标量，因为只有一行数据，如果都多列就是一个元组。后续使用的都是已经算好的值。</strong></p>
<h4 id="三元运算符优化"><a href="#三元运算符优化" class="headerlink" title="三元运算符优化"></a>三元运算符优化</h4><p><strong>如果开启了 optimize_if_chain_to_multiif 参数，那么三元运算符会被替换成 ，multiIf 函数，之前说过，这里就不再赘述了。</strong></p>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p><strong>介绍了一些 ClickHouse 的优化规则，我们来看一下在编写 SQL 时如何手动进行优化，或者说有哪些可以优化的点。因为 ClickHouse 的优化规则（或者说内置的优化器）实在太简单了，但凡有点关系型数据库经验的人都不会那么写，因此在编写 SQL 语句的时候只能靠我们保证质量。那么来看看都有哪些注意的点。</strong></p>
<h4 id="PREWHERE-替代-WHERE"><a href="#PREWHERE-替代-WHERE" class="headerlink" title="PREWHERE 替代 WHERE"></a>PREWHERE 替代 WHERE</h4><p><strong>PREWHERE 和 WHERE 语句的作用相同，用来过滤数据，但是 PREWHERE 只支持 MergeTree 系列的引擎。WHERE 语句是读取所有的字段，然后进行数据过滤，而 PREWHERE 则是指定了哪些字段就读取哪些字段。比如 age &gt; 18 and length &gt; 160，WHERE 的话会读取全部字段，然后进行数据过滤，再根据 SELECT 中指定的字段进行丢弃。PREWHERE 则是只读取 age 和 length 两个字段，因为过滤条件只有这两个字段，而将数据过滤之后，再根据 SELECT 中指定的字段进行补全（或丢弃）。</strong></p>
<p><strong>所以两者的区别在于读取的数据量不同，当查询列明显多于筛选列时，使用 PREWHERE 可以十倍提升性能。当然这些我们之前在介绍子句的时候说过了，并且我们说过 ClickHouse 会自动将 WHERE 优化成 PREWHERE，因此我们直接用 WHERE 就好。当然我们还说了有几种情况，ClickHouse 不会自动优化，因为在这几种情况下，优化带来的性能提升不大，具体可以回去看看。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">WHERE</span> UserID <span class="operator">=</span> <span class="number">610708775678702928</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184338754-748042245.png" alt="img"></p>
<p><strong>在使用 * 的时候，ClickHouse 会自动展开成所有字段，然后重点是我们看到 WHERE 被替换成了 PREWHERE，证明确实会自动优化，当然我们说过可以通过设置 optimize_move_to_prewhere 为 1、0 进行开启、关闭，默认是开启的。另外这个配置可以通过 set 设置，那么它位于哪里呢？没错，显然是 users.xml 中。</strong></p>
<h4 id="数据采样"><a href="#数据采样" class="headerlink" title="数据采样"></a>数据采样</h4><p><strong>当我们要求数据的实时性高于数据的准确性时，数据采样就很有用了。记得在大四实习的时候，当时负责给各大上市公司做审计，由于数据量非常庞大，算一次要花上好几个小时。所以每次都先采样，只算百分之 10 到百分之 20 的数据，如果得出来的结果符合正常预期，那么再跑全量数据，这样会稳妥一些。如果上来就跑全量数据，最后发现结果算的不对就尴尬了。</strong></p>
<p><strong>当然我当时选择采样只是简单的对程序的准确性进行一些检测，但实际生产中的程序基本上都是准确的，这个时候如果用户执行了一个查询，那么为了很快的给出结果，选择随机采样是最合适的方式。以我之前的经验，如果数据倾斜不严重的话，那么采样 10% 的数据和全量数据计算出来的结果差别很小，当然具体怎么做还是要取决于你的业务。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... SAMPLE <span class="number">0.1</span></span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p><strong>SAMPLE 放在 FROM 之后、WHERE 之前，至于具体用法之前已经说过了，可以回头看一下。</strong></p>
<h4 id="列裁剪与分区裁剪"><a href="#列裁剪与分区裁剪" class="headerlink" title="列裁剪与分区裁剪"></a>列裁剪与分区裁剪</h4><p><strong>ClickHouse 非常适合存储大数据量的宽表，因此我们应该避免使用 SELECT * 操作，这是一个非常影响的操作。应当对列进行裁剪，只选择你需要的列，因为字段越少，消耗的 IO 资源就越少，从而性能就越高。</strong></p>
<p><strong>而分区裁剪就是只读取需要分区，在过滤条件中指定，所以设计一个合适的分区表对后期查询是非常有帮助的。。</strong></p>
<h4 id="ORDER-BY-应当于-WHERE、LIMIT-一起使用"><a href="#ORDER-BY-应当于-WHERE、LIMIT-一起使用" class="headerlink" title="ORDER BY 应当于 WHERE、LIMIT 一起使用"></a>ORDER BY 应当于 WHERE、LIMIT 一起使用</h4><p><strong>对千万级以上的数据集进行排序的时候一定要搭配 WHERE 或 LIMIT 使用，可能有人觉得我只是排个序而已，为啥还要有这么多限制。因为事实上我们很少会对数据进行全局排序，而且数据量一大，全局排序的话内存很容易爆掉；如果设置了 max_bytes_before_external_sort，那么全局排序会在磁盘上进行，此时速度又是一个难以忍受的地方。因此在使用 ORDER BY 的时候，需要搭配 WHERE、LIMIT。</strong></p>
<h4 id="避免构建虚拟列"><a href="#避免构建虚拟列" class="headerlink" title="避免构建虚拟列"></a>避免构建虚拟列</h4><p><strong>虚拟列指的就是我们自己构造出来的字段，而在原表中是没有的，举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A, A <span class="operator">+</span> <span class="number">1</span> <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p><strong>A 是表中的字段，但 A + 1 明显不是，它是我们构造出来的，所以叫虚拟列。但如果非必须的话，最好不要再结果集上构造虚拟机列，因为虚拟列非常消耗资源性能，可以考虑在拿到数据之后由前后端进行处理。</strong></p>
<h4 id="uniqCombined-替代-count-DISTINCT"><a href="#uniqCombined-替代-count-DISTINCT" class="headerlink" title="uniqCombined 替代 count(DISTINCT)"></a>uniqCombined 替代 count(DISTINCT)</h4><p><strong>我们之前说过 ClickHouse 提供了一些语法糖，例如这里的 count(DISTINCT column) 实际上就是 countDistinct(column)，只不过 ClickHouse 提供了类似于关系型数据库中 count(DISTINCT) 语法。并且在具体执行的时候，底层都对应 uniqExact 函数，举个例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> UserID), countDistinct(UserID), uniqExact(UserID) </span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184348897-1208726092.png" alt="img"></p>
<p><strong>但还是建议使用 count(DISTINCT)，因为这几个都是等价的，那么自然选一个看起来最熟悉的。那么这个我们说的 uniqCombined 有什么关系呢？原因是 uniqExact 是精确去重并统计数量，如果我们在数量上对统计的数据的误差有一定的容忍性，那么可以使用 uniqCombined，该函数使用类似 HyperLogLog 的算法，在速度上可以提升 10 倍以上，但牺牲了一些准确率。</strong></p>
<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184359366-125449336.png" alt="img"></p>
<h4 id="JOIN-操作"><a href="#JOIN-操作" class="headerlink" title="JOIN 操作"></a>JOIN 操作</h4><p><strong>在介绍 JOIN 之前我先说两句，很多公司在设计关系型数据库的表结构时，都会遵循相应的范式，但对于数据仓库而言是完全不需要的，数仓的重点在于分层。对于 OLAP 型的列式存储数据库而言，尤其是 ClickHouse，能不用 JOIN 就不用 JOIN，最好是单表操作，因此这就需要我们保证数据有冗余度，但这在数仓建设中完全 OK 。并且对于 ClickHouse 而言，它的 JOIN 也是比较奇葩的，那么它是怎么做的呢？</strong></p>
<p><strong>首先不管是 LEFT 还是 RIGHT，当 A 表和 B 表进行 JOIN 的时候，ClickHouse 都会将 B 表加载到内存，然后遍历 A 表数据，查询 B 表中有没有能与之关联上的数据，因此这就引出了第一个优化的原则：当大小表 JOIN 的时候，要保证小表在右侧。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- hits_v1 的数据量要远大于 visits_v1，然后我们来 JOIN 试一下</span></span><br><span class="line"><span class="comment">-- 这里为了避免输出大量信息，我们使用 count(*) 代替</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> datasets.hits_v1 a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v1 b</span><br><span class="line"><span class="keyword">USING</span>(CounterID);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上面是 hits_v1 作为左表进行左关联，等价于如下：将 hits_v1 作为右表进行右关联</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> datasets.visits_v1 b</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> datasets.hits_v1 a</span><br><span class="line"><span class="keyword">USING</span>(CounterID);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/1229382-20210913184416415-1275656254.png" alt="img"></p>
<p><strong>我们看到效率确实有差异，而 JOIN 之后的数据量比 hits_v1 表还要多，说明中间产生了笛卡尔积。如果不想产生笛卡尔积，那么只需要在 LEFT JOIN 和 RIGHT JOIN 的前面加上 ANY 即可，默认是 ALL。</strong></p>
<blockquote>
<p><strong>但还是上面那句话，能不用 JOIN 就不要用 JOIN，当涉及到两张表的时候，看看是否可以用子查询来替代。</strong></p>
</blockquote>
<p><strong>然后是谓词下推，我们举个栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.UserID, a.Age, b.CounterID </span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v1 b</span><br><span class="line"><span class="keyword">USING</span>(CounterID) <span class="keyword">WHERE</span> a.EventDate <span class="operator">=</span> <span class="string">&#x27;2020-04-17&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>上面会先对两张表进行 JOIN，完事之后再进行过滤，既然如此的话，那么为什么不能先过滤然后再进行 JOIN 呢？</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span>, b.CounterID </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> UserID, Age <span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">WHERE</span> EventDate <span class="operator">=</span> <span class="string">&#x27;2020-04-17&#x27;</span>) a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v1 b</span><br><span class="line"><span class="keyword">USING</span>(CounterID) </span><br></pre></td></tr></table></figure>

<p><strong>下面的做法会比上面要快，因为在 JOIN 之前就将数据过滤掉了一部分，不要小看这一点，有时对性能的影响很大。并且 ClickHouse 不会主动帮我们发起谓词下推的操作，需要我们自己手动完成。可能有人好奇，如果将过滤条件放在 ON 子句后面会怎么样，答案是会报错，因为 ClickHouse 不允许 ON 子句中出现过滤条件。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>以上就是 ClickHouse 关于优化方面的内容，说实话都比较简单，总之重点就是我们在写 SQL 的时候一定要注意，不能够随心所欲，因为 ClickHouse 所能做到的优化是非常有限的。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hesay.cn">wenwen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hesay.cn/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/">https://hesay.cn/2023/04/11/ClickHouse%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5(%E5%8D%81%E5%85%AD)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hesay.cn" target="_blank">热心市民温温</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ClickHouse/">ClickHouse</a></div><div class="post_share"><div class="social-share" data-image="/img/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/11/ClickHouse%20%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD(%E5%8D%81)/" title="ClickHouse 数组的相关操作函数，一网打尽(十)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ClickHouse 数组的相关操作函数，一网打尽(十)</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/11/ClickHouse%20%E7%9A%84%E5%89%AF%E6%9C%AC%E4%B8%8E%E5%88%86%E7%89%87(%E5%8D%81%E4%B8%83)/" title="ClickHouse 的副本与分片(十七)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ClickHouse 的副本与分片(十七)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0(%E5%8D%81%E4%B8%80)/" title="ClickHouse 中的常用聚合函数(十一)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中的常用聚合函数(十一)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中其它常见的表引擎(八)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/" title="ClickHouse 中的数据查询以及各种子句(九)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中的数据查询以及各种子句(九)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/" title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E5%85%B6%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%20(%E5%8D%81%E4%BA%94)/" title="ClickHouse 其它的一些操作函数 (十五)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 其它的一些操作函数 (十五)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E%EF%BC%9AMergeTree%20%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E5%85%AD)/" title="ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenwen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenlinshan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">码海无涯。。。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ClickHouse-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-%E5%8D%81%E5%85%AD"><span class="toc-number">1.</span> <span class="toc-text">ClickHouse 的执行计划以及优化策略(十六)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">1.0.1.</span> <span class="toc-text">执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.2.</span> <span class="toc-text">建表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%92%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">分区和索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">表参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">写入和删除优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">常见配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClickHouse-%E8%AF%AD%E6%B3%95%E4%BC%98%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-number">1.0.3.</span> <span class="toc-text">ClickHouse 语法优化规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#COUNT-%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">COUNT 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D%E4%B8%8B%E6%8E%A8"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">谓词下推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E8%A1%A8%E8%BF%9B%E8%A1%8C-JOIN-%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%9A%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">作为表进行 JOIN 的子查询会消除重复字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E8%AE%A1%E7%AE%97%E5%A4%96%E6%8E%A8"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">聚合计算外推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%B6%88%E9%99%A4"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">聚合函数消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-ORDER-BY-KEY"><span class="toc-number">1.0.3.6.</span> <span class="toc-text">删除重复的 ORDER BY KEY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-LIMIT-BY-KEY"><span class="toc-number">1.0.3.7.</span> <span class="toc-text">删除重复的 LIMIT BY KEY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-USING-KEY"><span class="toc-number">1.0.3.8.</span> <span class="toc-text">删除重复的 USING KEY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.0.3.9.</span> <span class="toc-text">标量替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.3.10.</span> <span class="toc-text">三元运算符优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.4.</span> <span class="toc-text">查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PREWHERE-%E6%9B%BF%E4%BB%A3-WHERE"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">PREWHERE 替代 WHERE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">数据采样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A3%81%E5%89%AA%E4%B8%8E%E5%88%86%E5%8C%BA%E8%A3%81%E5%89%AA"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">列裁剪与分区裁剪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ORDER-BY-%E5%BA%94%E5%BD%93%E4%BA%8E-WHERE%E3%80%81LIMIT-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">ORDER BY 应当于 WHERE、LIMIT 一起使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%88%97"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">避免构建虚拟列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniqCombined-%E6%9B%BF%E4%BB%A3-count-DISTINCT"><span class="toc-number">1.0.4.6.</span> <span class="toc-text">uniqCombined 替代 count(DISTINCT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JOIN-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.4.7.</span> <span class="toc-text">JOIN 操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.0.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/spring%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1/" title="spring中多线程情况下如何保证事务">spring中多线程情况下如何保证事务</a><time datetime="2023-07-25T07:34:45.332Z" title="发表于 2023-07-25 15:34:45">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0(%E5%8D%81%E4%B8%80)/" title="ClickHouse 中的常用聚合函数(十一)">ClickHouse 中的常用聚合函数(十一)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)">ClickHouse 中其它常见的表引擎(八)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/" title="ClickHouse 中的数据查询以及各种子句(九)">ClickHouse 中的数据查询以及各种子句(九)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/" title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wenwen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>