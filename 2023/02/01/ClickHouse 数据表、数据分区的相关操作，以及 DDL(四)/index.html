<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>ClickHouse 数据表、数据分区的相关操作，以及 DDL(四) | 热心市民温温</title><meta name="author" content="wenwen"><meta name="copyright" content="wenwen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)​																	本文来源： (https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;p&#x2F;15218664.html   楔子在知晓了 ClickHouse 的主要数据类型之后，接下来我们开始介绍 DDL 操作以及定义数据的方法，DDL 查询提供了数据表的创建、修改和删除操作，是最常用的功能之一">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)">
<meta property="og:url" content="https://hesay.cn/2023/02/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A%20DDL(%E5%9B%9B)/index.html">
<meta property="og:site_name" content="热心市民温温">
<meta property="og:description" content="ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)​																	本文来源： (https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;p&#x2F;15218664.html   楔子在知晓了 ClickHouse 的主要数据类型之后，接下来我们开始介绍 DDL 操作以及定义数据的方法，DDL 查询提供了数据表的创建、修改和删除操作，是最常用的功能之一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hesay.cn/img/favicon.png">
<meta property="article:published_time" content="2023-02-01T09:04:31.000Z">
<meta property="article:modified_time" content="2023-02-13T09:06:57.974Z">
<meta property="article:author" content="wenwen">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hesay.cn/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hesay.cn/2023/02/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A%20DDL(%E5%9B%9B)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-13 17:06:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="热心市民温温"><span class="site-name">热心市民温温</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-01T09:04:31.000Z" title="发表于 2023-02-01 17:04:31">2023-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-13T09:06:57.974Z" title="更新于 2023-02-13 17:06:57">2023-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ClickHouse/">ClickHouse</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="ClickHouse-数据表、数据分区的相关操作，以及-DDL-四"><a href="#ClickHouse-数据表、数据分区的相关操作，以及-DDL-四" class="headerlink" title="ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)"></a>ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)</h1><p>​																	本文来源： (<a target="_blank" rel="noopener" href="https://www.cnblogs.com/traditional/p/15218664.html">https://www.cnblogs.com/traditional/p/15218664.html</a> </p>
<hr>
<h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>在知晓了 ClickHouse 的主要数据类型之后，接下来我们开始介绍 DDL 操作以及定义数据的方法，DDL 查询提供了数据表的创建、修改和删除操作，是最常用的功能之一。</strong></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><strong>数据库起到了命名空间的作用，可以有效规避命名冲突的问题，也为后续的数据隔离提供了支撑。任何一张数据表，都必须归属在某个数据库之下。创建数据库的完整语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> db_name[ENGINE <span class="operator">=</span> engine]</span><br></pre></td></tr></table></figure>

<p><strong>IF NOT EXISTS 表示如果已经存在一个同名的数据库，则会忽略后续的创建过程；[ENGINE &#x3D; engine] 表示数据库所使用的引擎类型（是的，你没看错，数据库也支持设置引擎）。</strong></p>
<p><strong>数据库目前一共支持 5 种引擎，如下所示。</strong></p>
<ul>
<li><code>Ordinary：默认引擎，在绝大多数情况下我们都会使用默认引擎，使用时无须刻意声明，在此数据库下可以使用任意类型的表引擎</code></li>
<li><code>Dictionary：字典引擎，此类数据库会自动为所有数据字典创建它们的数据表，关于数据字典的详细介绍会在后面展开</code></li>
<li><code>Memory：内存引擎，用于存放临时数据。此类数据库下的数据表只会停留在内存中，不会涉及任何磁盘操作，当服务重启后数据会被清除</code></li>
<li><code>Lazy：日志引擎，此类数据库下只能使用 Log 系列的表引擎，关于 Log 表引擎的详细介绍会后续章节展开</code></li>
<li><code>MySQL：MySQL 引擎，此类数据库下会自动拉取远端 MySQL 中的数据，并为它们创建 MySQL 表引擎的数据表，关于MySQL表引擎的详细介绍也会在后续章节展开。</code></li>
</ul>
<p><strong>在绝大多数情况下都只需使用默认的数据库引擎，例如执行下面的语句，便能够创建属于我们的第一个数据库：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE kagura_nana;</span><br></pre></td></tr></table></figure>

<p><strong>数据库的实质就是物理磁盘上的一个目录文件，所以在语句执行之后，ClickHouse 便会在安装路径下创建 kagura_nana 数据库的目录文件。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@satori ~]<span class="comment"># ls /var/lib/clickhouse/data/</span></span><br><span class="line">default  kagura_nana  system</span><br><span class="line">[root@satori ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><strong>与此同时，在 metadata 路径下也会一同创建用于恢复数据库的 kagura_nana.sql 文件：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@satori ~]<span class="comment"># ls /var/lib/clickhouse/metadata/</span></span><br><span class="line">default  default.sql  kagura_nana  kagura_nana.sql  system  system.sql</span><br><span class="line">[root@satori ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 SHOW DATABASES 查询，能够返回 ClickHouse 当前的数据库列表:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">satori :) <span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line"></span><br><span class="line">Query id: <span class="number">2</span>a4de6ad<span class="number">-535</span>f<span class="number">-489</span>f<span class="number">-955</span>e<span class="operator">-</span>dae511a18415</span><br><span class="line"></span><br><span class="line">┌─name────────┐</span><br><span class="line">│ <span class="keyword">default</span>     │</span><br><span class="line">│ kagura_nana │</span><br><span class="line">│ <span class="keyword">system</span>      │</span><br><span class="line">└─────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br><span class="line"></span><br><span class="line">satori :)</span><br></pre></td></tr></table></figure>

<p><strong>使用 USE 查询可以实现在多个数据库之间进行切换，而通过 SHOW TABLES 查询可以查看当前数据库中存在的所以数据表。删除一个数据库，则需要用到下面的 DROP 查询。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] db_name;</span><br></pre></td></tr></table></figure>

<h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><p><strong>我们说数据库在物理磁盘上对应一个目录文件，而表则是在数据库对应的目录文件里面再创建一个目录文件，比如我们在数据库 kagura_nana 里面创建一张表 t，那么相当于在 &#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;data&#x2F;kagura_nana 里面创建一个目录文件 t，而往表 t 里面写的数据则会在目录 t 中以文本文件的形式保存，所以整个逻辑还是比较清晰好理解的。而 ClickHouse 数据表的定义语法，是在标准 SQL 的基础之上建立的，所以熟悉数据库的你在看到接下来的语法时，应该会感到很熟悉。ClickHouse 目前提供了三种最基本的建表方法：</strong></p>
<p><strong>第一种是常规定义方法，它的完整语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name (</span><br><span class="line">    column_name1 type [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>ALIAS expr],</span><br><span class="line">    column_name2 type [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>ALIAS expr],</span><br><span class="line">    ......</span><br><span class="line">) ENGINE <span class="operator">=</span> engine</span><br></pre></td></tr></table></figure>

<p><strong>使用 [db_name.] 参数可以为数据表指定数据库，如果不指定此参数，则默认会使用 default 数据库。注意结尾的 ENGINE 参数，它被用于指定数据表的引擎，表引擎决定了数据表的特性，也决定了数据将会被如何存储以及如何加载。例如 Memory 表引擎，它是 ClickHouse 最简单的表引擎，数据只会被保存在内存中，在服务重启时数据会丢失。我们会在后续章节详细介绍数据表引擎，此处暂不展开。</strong></p>
<p><strong>第二种定义方法是复制其他表的结构，具体语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name1.]table_name1 <span class="keyword">AS</span> [db_name2.]table_name2 [ENGINE <span class="operator">=</span> engine]</span><br></pre></td></tr></table></figure>

<p><strong>这种方式支持在不同的数据库之间复制表结构，例如下面的语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 A 库下的 a 表拷贝一份到 B 库下的 b 表, 注意：引擎可以更换</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> A.a <span class="keyword">AS</span> B.b ENGINE <span class="operator">=</span> TinyLog</span><br></pre></td></tr></table></figure>

<p><strong>第三种定义方法是通过 SELECT 子句的形式创建，它的完整语法如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name].table_name ENGINE <span class="operator">=</span> engine <span class="keyword">AS</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<p><strong>在这种方式下，不仅会根据 SELECT 子句建立相应的表结构，同时还会将 SELECT 子句查询的数据顺带写入，例如执行下面的语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> db.not_exists_table ENGINE <span class="operator">=</span> Memory <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> db.exists_table</span><br></pre></td></tr></table></figure>

<p><strong>上述语句会将 SELECT * FROM db.exists_table 的查询结果一并写入数据表。</strong></p>
<p><strong>ClickHouse 和大多数数据库一样，使用 DESC 查询可以返回数据表的定义结构，另外如果想删除一张数据表，则可以使用下面的 DROP 语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] [db_name.]table_name</span><br></pre></td></tr></table></figure>

<h3 id="默认值表达式"><a href="#默认值表达式" class="headerlink" title="默认值表达式"></a>默认值表达式</h3><p><strong>表字段支持三种默认值表达式的定义方法，分别是 DEFAULT、MATERIALIZED 和 ALIAS。无论使用哪种形式，表字段一旦定义了默认值，那么便不再强制要求定义数据类型，因为 ClickHouse 会根据默认值进行类型推断。如果同时对表字段定义了数据类型和默认值表达式，则以明确定义的数据类型为主，例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (    id String,    col1 <span class="keyword">DEFAULT</span> <span class="number">100</span>,    col2 String <span class="keyword">DEFAULT</span> col1) ENGINE<span class="operator">=</span>Memory</span><br></pre></td></tr></table></figure>

<p><strong>col1 字段没有定义数据类型，默认值为整型 1000；col2 字段定义了数据类型和默认值，且默认值等于 col1，现在写入测试数据。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(id) <span class="keyword">VALUES</span>(<span class="string">&#x27;AAA&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在写入之后执行以下查询：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">satori :) <span class="keyword">SELECT</span> id, col1, col2, toTypeName(col1), toTypeName(col2) <span class="keyword">from</span> table_nameSELECT    id,    col1,    col2,    toTypeName(col1),    toTypeName(col2)<span class="keyword">FROM</span> table_nameQuery id: d9114fe3<span class="number">-172</span>f<span class="number">-4e2</span>f<span class="operator">-</span>bd2a<span class="number">-13</span>b514015de9┌─id──┬─col1─┬─col2─┬─toTypeName(col1)─┬─toTypeName(col2)─┐│ AAA │  <span class="number">100</span> │ <span class="number">100</span>  │ UInt8            │ String           │└─────┴──────┴──────┴──────────────────┴──────────────────┘<span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.satori :)</span><br></pre></td></tr></table></figure>

<p><strong>由查询结果可以验证，默认值的优先级符合我们的预期，其中 col1 字段根据默认值被推断为 UInt16；而 col2 字段由于同时定义了数据类型和默认值，所以它最终的数据类型来自明确定义的 String。</strong></p>
<hr>
<p><strong>默认值表达式的三种定义方法之间也存在着不同之处，可以从如下三个方面进行比较。</strong></p>
<p><strong>1）数据写入：在数据写入时，只有 DEFAULT 类型的字段可以出现在 INSERT 语句中，而 MATERIALIZED 和 ALIAS 都不能被显式赋值，它们只能依靠计算取值。例如试图为 MATERIALIZED 类型的字段写入数据，将会得到如下的错误。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB::Exception: Cannot <span class="keyword">insert</span> <span class="keyword">column</span> URL,because it <span class="keyword">is</span> MATERIALIZED column..</span><br></pre></td></tr></table></figure>

<p><strong>2）数据查询：在数据查询时，只有 DEFAULT 类型的字段可以通过 SELECT * 返回，而 MATERIALIZED 和 ALIAS 类型的字段不会出现在 SELECT * 查询的返回结果集中。</strong></p>
<p><strong>3）数据存储：在数据存储时，只有 DEFAULT 和 MATERIALIZED 类型的字段才支持持久化。如果使用的表引擎支持物理存储（例如 TinyLog 表引擎)，那么这些列字段将会拥有物理存储。而 ALIAS 类型的字段不支持持久化，它的取值总是需要依靠计算产生，数据不会落到磁盘。</strong></p>
<p><strong>可以使用 ALTER 语句修改默认值，例如:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [db_name.]table_name MODIFY COLOMN col_name DEFAUET <span class="keyword">value</span></span><br></pre></td></tr></table></figure>

<p><strong>修改动作并不会影响数据表内先前已经存在的数据，但是默认值的修改有诸多限制，例如在 MergeTree 表引擎中，它的主键字段是无法被修改的；而某些表引擎则完全不支持修改（例如 TinyLog）。</strong></p>
<h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><p><strong>ClickHouse 也有临时表的概念，创建临时表的方法是在普通表的基础之上添加 TEMPORARY 关键字，CREATE TEMPORARY TABLE…，剩余的部分和创建普通表完全一样。</strong></p>
<p><strong>相比普通表而言，临时表有如下两点特殊之处：</strong></p>
<ul>
<li><code>它的生命周期是会话绑定的，所以它只支持 Memory 表引擎，如果会话结束，数据表就会被销毁;</code></li>
<li><code>临时表不属于任何数据库，所以在它的建表语句中，既没有数据库参数也没有表引擎参数;</code></li>
</ul>
<p><strong>针对第二个特殊项，有人心中难免会产生一个疑问：既然临时表不属于任何数据库，如果临时表和普通表名称相同，会出现什么状况呢？接下来不妨做个测试。首先在 DEFAULT 数据库创建测试表并写入数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp_v1(title String) ENGINE <span class="operator">=</span> Memory;<span class="keyword">INSERT</span> <span class="keyword">INTO</span> tmp_v1 <span class="keyword">VALUES</span> (<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>接着创建一张名称相同的临时表并写入数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> tmp_v1(num UInt8) ENGINE <span class="operator">=</span> Memory;<span class="keyword">INSERT</span> <span class="keyword">INTO</span> tmp_v1 <span class="keyword">VALUES</span> (<span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<p><strong>现在查询 tmp_v1 看看会发生什么？</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">satori :) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tmp_v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tmp_v1</span><br><span class="line"></span><br><span class="line">Query id: ad4b5094<span class="number">-3627</span><span class="number">-4</span>af7<span class="operator">-</span>a207<span class="operator">-</span>bbd8ef90617a</span><br><span class="line"></span><br><span class="line">┌─num─┐</span><br><span class="line">│  <span class="number">22</span> │</span><br><span class="line">└─────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br><span class="line"></span><br><span class="line">satori :)</span><br></pre></td></tr></table></figure>

<p><strong>通过返回结果可以得出结论，临时表的优先级是大于普通表的。当两张数据表名称相同的时候，会优先读取临时表的数据。当然在 ClickHouse 的日常使用中，不会刻意地使用临时表，它更多被运用在 ClickHouse 的内部，是数据在集群之间传播的载体。</strong></p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p><strong>数据分区（partition）和数据分片（shard）是完全不同的而个概念，数据分区是针对本地数据而言的，是数据的一种纵向切分；而数据分片是数据的一种横向切分（后续章节会详细说）。数据分区对于一款 OLAP 数据库而言意义非凡，借助数据分区，在后续的查询过程中能够跳过不必要的数据目录，从而提升查询的性能。合理地利用分区特性，还可以变相实现数据的更新操作，因为数据分区支持删除、替换和重置操作。假设数据表按照月份分区，那么数据就可以按月份的粒度被替换更新。</strong></p>
<p><strong>分区虽好，但不是所有的表引擎都可以使用这项特性，目前只有合并树（MergeTree）家族系列的表引擎才支持数据分区。接下来通过一个简单的例子演示分区表的使用方法，首先由 PARTITION BY 指定分区键，例如下面的数据表 partition_v1 使用了日期字段作为分区键，并将其格式化为年月的形式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partition_v1 (</span><br><span class="line">    ID String,</span><br><span class="line">    URL String,</span><br><span class="line">    EventDate <span class="type">Date</span></span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ID</span><br></pre></td></tr></table></figure>

<p><strong>接着写入不同月份的测试数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> partition_v1 <span class="keyword">VALUES</span> (<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;www.a1.com&#x27;</span>, <span class="string">&#x27;2019-05-01&#x27;</span>), (<span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;www.a2.com&#x27;</span>, <span class="string">&#x27;2019-06-02&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>最后通过 system.parts 系统表，查询数据表的分区状态：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">table</span>, <span class="keyword">partition</span>, path <span class="keyword">FROM</span> system.parts <span class="keyword">WHERE</span> <span class="keyword">table</span> <span class="operator">=</span> <span class="string">&#x27;partition_v1&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A%20DDL(%E5%9B%9B)/1229382-20210816173455153-82548770.png" alt="img"></p>
<p><strong>可以看到，partition_v1 按年月划分后，目前拥有两个数据分区，且每个分区都对应一个独立的文件目录，用于保存各自部分的数据。</strong></p>
<p><strong>合理设计分区键非常重要，通常会按照数据表的查询场景进行针对性设计。例如在刚才示例中的数据表按年月分区，如果后续的查询按照分区键过滤，例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> partition_v1 <span class="keyword">WHERE</span> EventDate <span class="operator">=</span><span class="string">&#x27;2019-05-01&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>那么在后续的查询过程中，可以利用分区索引跳过 6 月份的分区目录，只加载 5 月份的数据，从而带来查询的性能提升。</strong></p>
<p><strong>当然，使用不合理的分区键也会适得其反，分区键不应该使用粒度过细的数据字段。例如按照小时分区，将会带来分区数量的急剧增长，从而导致性能下降。关于数据分区更详细的原理说明，也会在后续章节进行。</strong></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><strong>ClickHouse 拥有普通和物化两种视图，其中物化视图拥有独立的存储，我们一会说；而普通视图和关系型数据库中的视图类似，只是一层简单的查询代理。创建普通视图的完整语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]view_name <span class="keyword">AS</span> SELECT...</span><br></pre></td></tr></table></figure>

<p><strong>普通视图不会存储任何数据，它只是一层单纯的 SELECT 查询映射，起着简化查询、明晰语义的作用，对查询性能不会有任何增强。假设有一张普通视图 view_tb_v1，它是基于数据表 tb_v1 的 id 和 name 两个字段创建的，那么下面的两条 SELECT 查询是完全等价的：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> view_tb_v1;</span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> tb_v1;</span><br></pre></td></tr></table></figure>

<p><strong>而物化视图需要指定表引擎，数据保存形式由它的表引擎决定，创建物化视图的完整语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]view_name [<span class="keyword">TO</span> [db.]name] ENGINE <span class="operator">=</span> engine [POPULATE] <span class="keyword">AS</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<p><strong>我们来对这些语法规则举例说明，我们先来创建一张物化视图：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 物化视图本质上可以看成是一张特殊的数据表，在创建的时候也需要指定引擎</span></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> girls_view_1 ENGINE<span class="operator">=</span>TinyLog()</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> id, name, age <span class="keyword">FROM</span> girls;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到相较于普通视图，我们在创建物化的视图的时候，在 create 后面多写了一个 MATERIALIZED 来表示创建的是物化视图、以及指定了一个表引擎。但需要注意的是，物化视图是可以存储数据的。比如此时的物化视图 girls_view_1 是根据表 girls 的 id、name、age 三个字段创建的，如果之后再往 girls 里面写数据，那么新写入的数据对应的 id、name、age 就会同步到 girl_view_1 中。也就是说，物化视图创建好之后，如果源表被写入新数据，那么物化视图也会同步更新。</strong></p>
<p><strong>但需要注意的是，默认情况下，物化视图在创建时不会拷贝源表中的数据，它只会同步在此之后被写入源表的数据，所以当前 girls 里面的已存在的数据并没有写入到 girls_view_\1 中。如果希望在创建的物化视图的时候，就顺带把表中的数据也同步过去该怎么做呢？</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只需要在 AS SELECT 的前面加上 POPULATE 即可</span></span><br><span class="line"><span class="comment">-- 此时表 girls 的数据，更准确的说是 SELECT 查询得到的结果集才会进入物化视图中</span></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> girls_view_1 ENGINE<span class="operator">=</span>TinyLog()</span><br><span class="line">POPULATE <span class="keyword">AS</span> <span class="keyword">SELECT</span> id, name, age <span class="keyword">FROM</span> girls;</span><br></pre></td></tr></table></figure>

<p><strong>所以 POPULATE 修饰符决定了物化视图的初始化策略：如果使用了 POPULATE 修饰符，那么在创建视图的过程中，会连带将源表中已存在的数据（更准确的说是 SELECT 查询得到的结果集）一并导入。反之，如果不使用 POPULATE 修饰符，那么物化视图在创建之后是没有数据的，它只会同步在此之后被写入源表的数据。</strong></p>
<p><strong>另外物化视图本质是一张特殊的数据表，如果存在的话，那么使用 SHOW TABLE 也能查看到。而如果删除一个视图，则直接使用 DROP TABLE 即可，注意：没有 DROP VIEW，只要是视图，删除语句都是 DROP TABLE，所以这也侧面说明了视图名和表名不可以重复。</strong></p>
<p><strong>然后物化视图还有一个用法，首先创建一个物化视图的时候其实本质上还是会创建一张表，默认名称是 “ .inner.物化视图名 “，只不过这张表是隐藏的，其作用就是负责保存物化视图从源表中同步过来的数据。那么问题来了，负责存储物化视图数据的表可不可以我们自己指定呢？答案是可以的。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> girls_view_1 <span class="keyword">TO</span> other_girls</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> id, name, age <span class="keyword">FROM</span> girls;</span><br></pre></td></tr></table></figure>

<p><strong>物化视图在同步数据的时候就会将数据写入到 other_girls 中，当然 other_girls 的表结构与 SELECT 选择的字段的类型、数量要相匹配，并且此时我们既可以通过物化视图查看数据，也可以通过 other_girls 来查看。这种用法，我们后面介绍表引擎的时候会说，目前先了解物化视图的用法。</strong></p>
<h3 id="数据表的基本操作"><a href="#数据表的基本操作" class="headerlink" title="数据表的基本操作"></a>数据表的基本操作</h3><p><strong>目前只有 MergeTree、Merge 和 Distributed 这三类表引擎支持 ALTER 查询，如果现在还不明白这些表引擎的作用也不必担心，目前只需简单了解这些信息即可，后面会对它们进行介绍。</strong></p>
<h4 id="追加新字段"><a href="#追加新字段" class="headerlink" title="追加新字段"></a>追加新字段</h4><p><strong>假如需要对一张数据表追加新的字段，可以使用如下语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 字段名 [类型] [默认值] [插在哪个字段后面]</span><br></pre></td></tr></table></figure>

<h4 id="修改字段类型"><a href="#修改字段类型" class="headerlink" title="修改字段类型"></a>修改字段类型</h4><p><strong>如果需要改变表字段的数据类型或者默认值，需要使用下面的语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name MODIFY <span class="keyword">COLUMN</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 字段名 [类型] [默认值]</span><br></pre></td></tr></table></figure>

<p><strong>修改某个字段的数据类型，实质上会调用相应的 toType 转型方法。如果当前的类型与期望的类型不能兼容，则修改类型失败。例如将 String 类型的 IP 字段转成 IPv4 类型是可行的，但是转成 UInt 则会出现错误。</strong></p>
<h4 id="修改备注"><a href="#修改备注" class="headerlink" title="修改备注"></a>修改备注</h4><p><strong>做好信息备注是保持良好编程习惯的美德之一，所以如果你还没有为列字段添加备注信息，那么就赶紧行动吧。追加备注的语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name COMMENT <span class="keyword">COLUMN</span> [IF <span class="keyword">EXISTS</span>] 字段名 <span class="string">&#x27;some comment&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A%20DDL(%E5%9B%9B)/1229382-20210816173503361-1995846816.png" alt="img"></p>
<h4 id="删除已有字段"><a href="#删除已有字段" class="headerlink" title="删除已有字段"></a>删除已有字段</h4><p><strong>假如要删除某个字段，可以使用下面的语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> [IF <span class="keyword">EXISTS</span>] name</span><br></pre></td></tr></table></figure>

<p><strong>如果某个字段被删除，那么对应的数据也就被删除了。</strong></p>
<h4 id="移动数据表"><a href="#移动数据表" class="headerlink" title="移动数据表"></a>移动数据表</h4><p><strong>在 Linux 系统中，mv 命令的本意是将一个文件从原始位置 A 移动到目标位置 B，但是如果位置 A 与位置 B 相同，则可以变相实现重命名的作用。ClickHouse 的 RENAME 查询就与之有着异曲同工之妙，RENAME 语句的完整语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> [db_name1.]table_name1 <span class="keyword">TO</span> [db_name2.]table_name2, [db_name1.]table_name3 <span class="keyword">TO</span> [db_name2.]table_name3......</span><br></pre></td></tr></table></figure>

<p><strong>RENAME 可以修改数据表的名称，如果将原始数据库与目标数据库设为不同的名称，那么就可以实现数据表在两个数据库之间移动的效果，并且还可以同时移动多张。</strong></p>
<p><strong>需要注意的是，数据表的移动只能在单个节点的范围内。换言之，数据表移动的目标数据库和原始数据库必须在同一个服务节点内，而不能是集群中的远程节点。</strong></p>
<h4 id="清空数据表"><a href="#清空数据表" class="headerlink" title="清空数据表"></a>清空数据表</h4><p><strong>假设需要将表内的数据全部清空，而不是直接删除这张表，则可以使用 TRUNCATE 语句，它的完整语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] [db_name.]table_name</span><br></pre></td></tr></table></figure>

<h3 id="数据分区的基本操作"><a href="#数据分区的基本操作" class="headerlink" title="数据分区的基本操作"></a>数据分区的基本操作</h3><p><strong>了解并善用数据分区益处颇多，熟练掌握它的使用方法，可以为后续的程序设计带来极大的灵活性和便利性，目前只有 MergeTree 系列的表引擎支持数据分区。</strong></p>
<h4 id="查询分区信息"><a href="#查询分区信息" class="headerlink" title="查询分区信息"></a>查询分区信息</h4><p><strong>ClickHouse 内置了许多 system 系统表，用于查询自身的状态信息，其中 parts 系统表专门用于查询数据表的分区信息。例如执行下面的语句，就能够得到数据表 partition_v1 的分区状况:</strong></p>
<p><img src="/2023/02/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A%20DDL(%E5%9B%9B)/1229382-20210816173511827-810044396.png" alt="img"></p>
<p><strong>如上所示，目前 partition_v1 共拥有 2 个分区，其中 partition_id 或者 name 等同于分区的主键，可以基于它们的取值确定一个具体的分区。</strong></p>
<h4 id="删除指定分区"><a href="#删除指定分区" class="headerlink" title="删除指定分区"></a>删除指定分区</h4><p><strong>合理地设计分区键并利用分区的删除功能，就能够达到数据更新的目的，删除一个指定分区的语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> partition_expr</span><br></pre></td></tr></table></figure>

<p><strong>假如现在需要更新 partition_v1 数据表整个 6 月份的数据，则可以先将 6 月份的分区删除；</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> partition_v1 <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> <span class="number">201906</span></span><br></pre></td></tr></table></figure>

<p><strong>然后将整个 6 月份的新数据重新写入，就可以达到更新的目的。</strong></p>
<h4 id="复制分区数据"><a href="#复制分区数据" class="headerlink" title="复制分区数据"></a>复制分区数据</h4><p><strong>ClickHouse 支持将 A 表的分区数据复制到 B 表，这项特性可以用于快速数据写入、多表间数据同步和备份等场景，它的完整语法如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> B REPLACE <span class="keyword">PARTITION</span> partition_expr <span class="keyword">FROM</span> A</span><br></pre></td></tr></table></figure>

<p><strong>不过需要注意的是，并不是任意数据表之间都能够相互复制，它们还需要满足两个前提条件：</strong></p>
<ul>
<li><code>两张表需要拥有相同的分区键;</code></li>
<li><code>它们的表结构完全相同;</code></li>
</ul>
<p><strong>假设有一个数据表 partition_v2，并且与之前 partition_v1 的分区键和表结构完全相同，那么如果想将 partition_v1 中 5 月份的数据导入到 partition_v2中，就可以这么做。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> partition_v2 REPLACE <span class="keyword">PARTITION</span> <span class="number">201905</span> <span class="keyword">FROM</span> partition_v1</span><br></pre></td></tr></table></figure>

<h4 id="重置分区数据"><a href="#重置分区数据" class="headerlink" title="重置分区数据"></a>重置分区数据</h4><p><strong>如果数据表某一列的数据有误，需要将其重置为默认值，此时可以使用下面的语句实现:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name CLEAR <span class="keyword">COLUMN</span> column_name <span class="keyword">IN</span> <span class="keyword">PARTITION</span> partition_expr</span><br></pre></td></tr></table></figure>

<p><strong>首先如果声明了默认值表达式，那么以表达式为准；否则以相应数据类型的默认值为准，比如 String 类型的默认值就是空字符串。</strong></p>
<h4 id="装载与卸载分区"><a href="#装载与卸载分区" class="headerlink" title="装载与卸载分区"></a>装载与卸载分区</h4><p><strong>表分区可以通过 DETACH 语句卸载，分区被卸载后，它的物理数据并没有删除，而是被转移到了当前数据表目录的 detached 子目录下。而装载分区则是反向操作，它能够将 detached 子目录下的某个分区重新装载回去。卸载与装载这一对伴生的操作，常用于分区数据的迁移和备份场景。卸载某个分区的语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name DETACH <span class="keyword">PARTITION</span> partition_expr</span><br></pre></td></tr></table></figure>

<p><strong>假设有一个分区表 partition_v3，里面有很多月的数据，那么执行下面的语句就可以将该表中整个 8 月份的分区卸载。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> partition_v3 DETACH <span class="keyword">PARTITION</span> <span class="number">201908</span></span><br></pre></td></tr></table></figure>

<p><strong>此时再次查询这张表，会发现其中 2019 年 8 月份的数据已经没有了。而进入 partition_v3 的磁盘目录，则可以看到被卸载的分区目录已经被移动到了 detached 目录中。</strong></p>
<p><strong>记住，一旦分区被移动到了 detached 子日录，就代表它已经脱离了 ClickHouse 的管理，ClickHouse 并不会主动清理这些文件。这此分区文件会一直存在，除非我们主动删除或者使用 ATTACH 语句重新装载它们。装载某个分区的完整语法如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ATTACH <span class="keyword">PARTITION</span> partition_expr</span><br></pre></td></tr></table></figure>

<p><strong>再次执行下面的语句，就可以将刚才已被卸载的 201908 分区重新装载回去:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> partition_v3 ATTACH <span class="keyword">PARTITION</span> <span class="number">201908</span></span><br></pre></td></tr></table></figure>

<h4 id="备份与还原文件"><a href="#备份与还原文件" class="headerlink" title="备份与还原文件"></a>备份与还原文件</h4><p><strong>关于分区数据的备份，可以通过 FREEZE 与 FETCH 实现，由于目前还缺少相关的背景知识，所以我们在后续章节介绍。</strong></p>
<h3 id="分布式-DDL-执行"><a href="#分布式-DDL-执行" class="headerlink" title="分布式 DDL 执行"></a>分布式 DDL 执行</h3><p><strong>ClickHouse 支持集群模式，一个集群拥有 1 到多个节点。CREATE、ALTER、DROP、RENMAE 及 TRUNCATE 这些 DDL 语句，都支持分布式执行。这意味着，如果在集群中任意一个节点上执行 DDL 语句，那么集群中的每个节点都会以相同的顺序执行相同的语句。这项特性意义非凡，它就如同批处理命令一样，省去了需要依次去单个节点执行 DDL 的烦恼。</strong></p>
<p><strong>将一条普通的 DDL 语句转换成分布式执行十分简单，只需加上 ON CLUSTER cluster_name 声明即可。例如，执行下面的语句后将会对 ch_cluster 集群内的所有节点广播这条 DDL 语句。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partition_v4 <span class="keyword">ON</span> CLUSTER ch_cluster(</span><br><span class="line">    ID String,</span><br><span class="line">    URL String,</span><br><span class="line">    EventDate <span class="type">Date</span></span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ID</span><br></pre></td></tr></table></figure>

<p><strong>当然，如果现在执行这条语句是不会成功的。因为到目前为止还没有配置过 ClickHouse 的集群模式，目前还不存在一个名为 ch_cluster 的集群，这部内容会放到后续章节展开说明。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hesay.cn">wenwen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hesay.cn/2023/02/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A%20DDL(%E5%9B%9B)/">https://hesay.cn/2023/02/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A%20DDL(%E5%9B%9B)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hesay.cn" target="_blank">热心市民温温</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ClickHouse/">ClickHouse</a></div><div class="post_share"><div class="social-share" data-image="/img/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/01/ClickHouse%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9(%E4%BA%94)/" title="ClickHouse 数据表的增删改(五)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ClickHouse 数据表的增删改(五)</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/01/ClickHouse%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%89)/" title="ClickHouse 的数据类型(三)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ClickHouse 的数据类型(三)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0(%E5%8D%81%E4%B8%80)/" title="ClickHouse 中的常用聚合函数(十一)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中的常用聚合函数(十一)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中其它常见的表引擎(八)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/" title="ClickHouse 中的数据查询以及各种子句(九)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中的数据查询以及各种子句(九)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/" title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E5%85%B6%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%20(%E5%8D%81%E4%BA%94)/" title="ClickHouse 其它的一些操作函数 (十五)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 其它的一些操作函数 (十五)</div></div></a></div><div><a href="/2023/04/11/ClickHouse%20%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E%EF%BC%9AMergeTree%20%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E5%85%AD)/" title="ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">ClickHouse 中最重要的表引擎：MergeTree 的深度原理解析(六)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenwen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenlinshan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">码海无涯。。。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ClickHouse-%E6%95%B0%E6%8D%AE%E8%A1%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A-DDL-%E5%9B%9B"><span class="toc-number">1.</span> <span class="toc-text">ClickHouse 数据表、数据分区的相关操作，以及 DDL(四)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.0.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.0.2.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">数据表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.0.4.</span> <span class="toc-text">默认值表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-number">1.0.5.</span> <span class="toc-text">临时表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">1.0.6.</span> <span class="toc-text">分区表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">1.0.7.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.8.</span> <span class="toc-text">数据表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E6%96%B0%E5%AD%97%E6%AE%B5"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">追加新字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">修改字段类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%A4%87%E6%B3%A8"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">修改备注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E6%9C%89%E5%AD%97%E6%AE%B5"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">删除已有字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.0.8.5.</span> <span class="toc-text">移动数据表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.0.8.6.</span> <span class="toc-text">清空数据表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.9.</span> <span class="toc-text">数据分区的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%88%86%E5%8C%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">查询分区信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">删除指定分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.9.3.</span> <span class="toc-text">复制分区数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.9.4.</span> <span class="toc-text">重置分区数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E5%88%86%E5%8C%BA"><span class="toc-number">1.0.9.5.</span> <span class="toc-text">装载与卸载分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.9.6.</span> <span class="toc-text">备份与还原文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-DDL-%E6%89%A7%E8%A1%8C"><span class="toc-number">1.0.10.</span> <span class="toc-text">分布式 DDL 执行</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/spring%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1/" title="spring中多线程情况下如何保证事务">spring中多线程情况下如何保证事务</a><time datetime="2023-07-25T07:34:45.332Z" title="发表于 2023-07-25 15:34:45">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0(%E5%8D%81%E4%B8%80)/" title="ClickHouse 中的常用聚合函数(十一)">ClickHouse 中的常用聚合函数(十一)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%BC%95%E6%93%8E(%E5%85%AB)/" title="ClickHouse 中其它常见的表引擎(八)">ClickHouse 中其它常见的表引擎(八)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AD%90%E5%8F%A5(%E4%B9%9D)/" title="ClickHouse 中的数据查询以及各种子句(九)">ClickHouse 中的数据查询以及各种子句(九)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/ClickHouse%20%E4%B9%8B%20MergeTree%20%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E8%A1%A8%E5%BC%95%E6%93%8E(%E4%B8%83)/" title="ClickHouse 之 MergeTree 家族中的其它表引擎(七)">ClickHouse 之 MergeTree 家族中的其它表引擎(七)</a><time datetime="2023-04-11T09:04:31.000Z" title="发表于 2023-04-11 17:04:31">2023-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wenwen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>